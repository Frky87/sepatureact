import { n as __export, r as __toESM, t as __commonJS } from "./chunk-DUEDWNxO.js";

//#region node_modules/axios/lib/helpers/bind.js
/**
* Create a bound version of a function with a specified `this` context
*
* @param {Function} fn - The function to bind
* @param {*} thisArg - The value to be passed as the `this` parameter
* @returns {Function} A new function that will call the original function with the specified `this` context
*/
function bind$4(fn, thisArg) {
	return function wrap() {
		return fn.apply(thisArg, arguments);
	};
}

//#endregion
//#region node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf: getPrototypeOf$1 } = Object;
var { iterator, toStringTag: toStringTag$1 } = Symbol;
var kindOf = ((cache) => (thing) => {
	const str = toString.call(thing);
	return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));
var kindOfTest = (type) => {
	type = type.toLowerCase();
	return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
/**
* Determine if a value is an Array
*
* @param {Object} val The value to test
*
* @returns {boolean} True if value is an Array, otherwise false
*/
var { isArray: isArray$7 } = Array;
/**
* Determine if a value is undefined
*
* @param {*} val The value to test
*
* @returns {boolean} True if the value is undefined, otherwise false
*/
var isUndefined = typeOfTest("undefined");
/**
* Determine if a value is a Buffer
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a Buffer, otherwise false
*/
function isBuffer$1(val) {
	return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
/**
* Determine if a value is an ArrayBuffer
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is an ArrayBuffer, otherwise false
*/
var isArrayBuffer = kindOfTest("ArrayBuffer");
/**
* Determine if a value is a view on an ArrayBuffer
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
*/
function isArrayBufferView(val) {
	let result;
	if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
	else result = val && val.buffer && isArrayBuffer(val.buffer);
	return result;
}
/**
* Determine if a value is a String
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a String, otherwise false
*/
var isString$3 = typeOfTest("string");
/**
* Determine if a value is a Function
*
* @param {*} val The value to test
* @returns {boolean} True if value is a Function, otherwise false
*/
var isFunction$1 = typeOfTest("function");
/**
* Determine if a value is a Number
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a Number, otherwise false
*/
var isNumber$1 = typeOfTest("number");
/**
* Determine if a value is an Object
*
* @param {*} thing The value to test
*
* @returns {boolean} True if value is an Object, otherwise false
*/
var isObject = (thing) => thing !== null && typeof thing === "object";
/**
* Determine if a value is a Boolean
*
* @param {*} thing The value to test
* @returns {boolean} True if value is a Boolean, otherwise false
*/
var isBoolean$1 = (thing) => thing === true || thing === false;
/**
* Determine if a value is a plain Object
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a plain Object, otherwise false
*/
var isPlainObject$2 = (val) => {
	if (kindOf(val) !== "object") return false;
	const prototype$1 = getPrototypeOf$1(val);
	return (prototype$1 === null || prototype$1 === Object.prototype || Object.getPrototypeOf(prototype$1) === null) && !(toStringTag$1 in val) && !(iterator in val);
};
/**
* Determine if a value is an empty object (safely handles Buffers)
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is an empty object, otherwise false
*/
var isEmptyObject = (val) => {
	if (!isObject(val) || isBuffer$1(val)) return false;
	try {
		return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
	} catch (e) {
		return false;
	}
};
/**
* Determine if a value is a Date
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a Date, otherwise false
*/
var isDate$1 = kindOfTest("Date");
/**
* Determine if a value is a File
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a File, otherwise false
*/
var isFile = kindOfTest("File");
/**
* Determine if a value is a Blob
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a Blob, otherwise false
*/
var isBlob = kindOfTest("Blob");
/**
* Determine if a value is a FileList
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a File, otherwise false
*/
var isFileList = kindOfTest("FileList");
/**
* Determine if a value is a Stream
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a Stream, otherwise false
*/
var isStream = (val) => isObject(val) && isFunction$1(val.pipe);
/**
* Determine if a value is a FormData
*
* @param {*} thing The value to test
*
* @returns {boolean} True if value is an FormData, otherwise false
*/
var isFormData = (thing) => {
	let kind;
	return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
};
/**
* Determine if a value is a URLSearchParams object
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a URLSearchParams object, otherwise false
*/
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = [
	"ReadableStream",
	"Request",
	"Response",
	"Headers"
].map(kindOfTest);
/**
* Trim excess whitespace off the beginning and end of a string
*
* @param {String} str The String to trim
*
* @returns {String} The String freed of excess whitespace
*/
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
/**
* Iterate over an Array or an Object invoking a function for each item.
*
* If `obj` is an Array callback will be called passing
* the value, index, and complete array for each item.
*
* If 'obj' is an Object callback will be called passing
* the value, key, and complete object for each property.
*
* @param {Object|Array<unknown>} obj The object to iterate
* @param {Function} fn The callback to invoke for each item
*
* @param {Object} [options]
* @param {Boolean} [options.allOwnKeys = false]
* @returns {any}
*/
function forEach(obj, fn, { allOwnKeys = false } = {}) {
	if (obj === null || typeof obj === "undefined") return;
	let i;
	let l;
	if (typeof obj !== "object") obj = [obj];
	if (isArray$7(obj)) for (i = 0, l = obj.length; i < l; i++) fn.call(null, obj[i], i, obj);
	else {
		if (isBuffer$1(obj)) return;
		const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
		const len = keys.length;
		let key;
		for (i = 0; i < len; i++) {
			key = keys[i];
			fn.call(null, obj[key], key, obj);
		}
	}
}
function findKey(obj, key) {
	if (isBuffer$1(obj)) return null;
	key = key.toLowerCase();
	const keys = Object.keys(obj);
	let i = keys.length;
	let _key;
	while (i-- > 0) {
		_key = keys[i];
		if (key === _key.toLowerCase()) return _key;
	}
	return null;
}
var _global = (() => {
	if (typeof globalThis !== "undefined") return globalThis;
	return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
/**
* Accepts varargs expecting each argument to be an object, then
* immutably merges the properties of each object and returns result.
*
* When multiple objects contain the same key the later object in
* the arguments list will take precedence.
*
* Example:
*
* ```js
* const result = merge({foo: 123}, {foo: 456});
* console.log(result.foo); // outputs 456
* ```
*
* @param {Object} obj1 Object to merge
*
* @returns {Object} Result of all merge properties
*/
function merge$1() {
	const { caseless, skipUndefined } = isContextDefined(this) && this || {};
	const result = {};
	const assignValue = (val, key) => {
		const targetKey = caseless && findKey(result, key) || key;
		if (isPlainObject$2(result[targetKey]) && isPlainObject$2(val)) result[targetKey] = merge$1(result[targetKey], val);
		else if (isPlainObject$2(val)) result[targetKey] = merge$1({}, val);
		else if (isArray$7(val)) result[targetKey] = val.slice();
		else if (!skipUndefined || !isUndefined(val)) result[targetKey] = val;
	};
	for (let i = 0, l = arguments.length; i < l; i++) arguments[i] && forEach(arguments[i], assignValue);
	return result;
}
/**
* Extends object a by mutably adding to it the properties of object b.
*
* @param {Object} a The object to be extended
* @param {Object} b The object to copy properties from
* @param {Object} thisArg The object to bind function to
*
* @param {Object} [options]
* @param {Boolean} [options.allOwnKeys]
* @returns {Object} The resulting value of object a
*/
var extend = (a, b$1, thisArg, { allOwnKeys } = {}) => {
	forEach(b$1, (val, key) => {
		if (thisArg && isFunction$1(val)) Object.defineProperty(a, key, {
			value: bind$4(val, thisArg),
			writable: true,
			enumerable: true,
			configurable: true
		});
		else Object.defineProperty(a, key, {
			value: val,
			writable: true,
			enumerable: true,
			configurable: true
		});
	}, { allOwnKeys });
	return a;
};
/**
* Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
*
* @param {string} content with BOM
*
* @returns {string} content value without BOM
*/
var stripBOM = (content) => {
	if (content.charCodeAt(0) === 65279) content = content.slice(1);
	return content;
};
/**
* Inherit the prototype methods from one constructor into another
* @param {function} constructor
* @param {function} superConstructor
* @param {object} [props]
* @param {object} [descriptors]
*
* @returns {void}
*/
var inherits = (constructor, superConstructor, props, descriptors) => {
	constructor.prototype = Object.create(superConstructor.prototype, descriptors);
	Object.defineProperty(constructor.prototype, "constructor", {
		value: constructor,
		writable: true,
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(constructor, "super", { value: superConstructor.prototype });
	props && Object.assign(constructor.prototype, props);
};
/**
* Resolve object with deep prototype chain to a flat object
* @param {Object} sourceObj source object
* @param {Object} [destObj]
* @param {Function|Boolean} [filter]
* @param {Function} [propFilter]
*
* @returns {Object}
*/
var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
	let props;
	let i;
	let prop;
	const merged = {};
	destObj = destObj || {};
	if (sourceObj == null) return destObj;
	do {
		props = Object.getOwnPropertyNames(sourceObj);
		i = props.length;
		while (i-- > 0) {
			prop = props[i];
			if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
				destObj[prop] = sourceObj[prop];
				merged[prop] = true;
			}
		}
		sourceObj = filter !== false && getPrototypeOf$1(sourceObj);
	} while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
	return destObj;
};
/**
* Determines whether a string ends with the characters of a specified string
*
* @param {String} str
* @param {String} searchString
* @param {Number} [position= 0]
*
* @returns {boolean}
*/
var endsWith = (str, searchString, position) => {
	str = String(str);
	if (position === void 0 || position > str.length) position = str.length;
	position -= searchString.length;
	const lastIndex = str.indexOf(searchString, position);
	return lastIndex !== -1 && lastIndex === position;
};
/**
* Returns new array from array like object or null if failed
*
* @param {*} [thing]
*
* @returns {?Array}
*/
var toArray = (thing) => {
	if (!thing) return null;
	if (isArray$7(thing)) return thing;
	let i = thing.length;
	if (!isNumber$1(i)) return null;
	const arr = new Array(i);
	while (i-- > 0) arr[i] = thing[i];
	return arr;
};
/**
* Checking if the Uint8Array exists and if it does, it returns a function that checks if the
* thing passed in is an instance of Uint8Array
*
* @param {TypedArray}
*
* @returns {Array}
*/
var isTypedArray = ((TypedArray$1) => {
	return (thing) => {
		return TypedArray$1 && thing instanceof TypedArray$1;
	};
})(typeof Uint8Array !== "undefined" && getPrototypeOf$1(Uint8Array));
/**
* For each entry in the object, call the function with the key and value.
*
* @param {Object<any, any>} obj - The object to iterate over.
* @param {Function} fn - The function to call for each entry.
*
* @returns {void}
*/
var forEachEntry = (obj, fn) => {
	const _iterator = (obj && obj[iterator]).call(obj);
	let result;
	while ((result = _iterator.next()) && !result.done) {
		const pair = result.value;
		fn.call(obj, pair[0], pair[1]);
	}
};
/**
* It takes a regular expression and a string, and returns an array of all the matches
*
* @param {string} regExp - The regular expression to match against.
* @param {string} str - The string to search.
*
* @returns {Array<boolean>}
*/
var matchAll = (regExp, str) => {
	let matches;
	const arr = [];
	while ((matches = regExp.exec(str)) !== null) arr.push(matches);
	return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
	return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
		return p1.toUpperCase() + p2;
	});
};
var hasOwnProperty$3 = (({ hasOwnProperty: hasOwnProperty$4 }) => (obj, prop) => hasOwnProperty$4.call(obj, prop))(Object.prototype);
/**
* Determine if a value is a RegExp object
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a RegExp object, otherwise false
*/
var isRegExp$2 = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
	const descriptors = Object.getOwnPropertyDescriptors(obj);
	const reducedDescriptors = {};
	forEach(descriptors, (descriptor, name) => {
		let ret;
		if ((ret = reducer(descriptor, name, obj)) !== false) reducedDescriptors[name] = ret || descriptor;
	});
	Object.defineProperties(obj, reducedDescriptors);
};
/**
* Makes all methods read-only
* @param {Object} obj
*/
var freezeMethods = (obj) => {
	reduceDescriptors(obj, (descriptor, name) => {
		if (isFunction$1(obj) && [
			"arguments",
			"caller",
			"callee"
		].indexOf(name) !== -1) return false;
		const value = obj[name];
		if (!isFunction$1(value)) return;
		descriptor.enumerable = false;
		if ("writable" in descriptor) {
			descriptor.writable = false;
			return;
		}
		if (!descriptor.set) descriptor.set = () => {
			throw Error("Can not rewrite read-only method '" + name + "'");
		};
	});
};
var toObjectSet = (arrayOrString, delimiter) => {
	const obj = {};
	const define = (arr) => {
		arr.forEach((value) => {
			obj[value] = true;
		});
	};
	isArray$7(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
	return obj;
};
var noop$2 = () => {};
var toFiniteNumber = (value, defaultValue) => {
	return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
/**
* If the thing is a FormData object, return true, otherwise return false.
*
* @param {unknown} thing - The thing to check.
*
* @returns {boolean}
*/
function isSpecCompliantForm(thing) {
	return !!(thing && isFunction$1(thing.append) && thing[toStringTag$1] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
	const stack = new Array(10);
	const visit = (source, i) => {
		if (isObject(source)) {
			if (stack.indexOf(source) >= 0) return;
			if (isBuffer$1(source)) return source;
			if (!("toJSON" in source)) {
				stack[i] = source;
				const target = isArray$7(source) ? [] : {};
				forEach(source, (value, key) => {
					const reducedValue = visit(value, i + 1);
					!isUndefined(reducedValue) && (target[key] = reducedValue);
				});
				stack[i] = void 0;
				return target;
			}
		}
		return source;
	};
	return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
	if (setImmediateSupported) return setImmediate;
	return postMessageSupported ? ((token, callbacks) => {
		_global.addEventListener("message", ({ source, data }) => {
			if (source === _global && data === token) callbacks.length && callbacks.shift()();
		}, false);
		return (cb) => {
			callbacks.push(cb);
			_global.postMessage(token, "*");
		};
	})(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(typeof setImmediate === "function", isFunction$1(_global.postMessage));
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
var utils_default = {
	isArray: isArray$7,
	isArrayBuffer,
	isBuffer: isBuffer$1,
	isFormData,
	isArrayBufferView,
	isString: isString$3,
	isNumber: isNumber$1,
	isBoolean: isBoolean$1,
	isObject,
	isPlainObject: isPlainObject$2,
	isEmptyObject,
	isReadableStream,
	isRequest,
	isResponse,
	isHeaders,
	isUndefined,
	isDate: isDate$1,
	isFile,
	isBlob,
	isRegExp: isRegExp$2,
	isFunction: isFunction$1,
	isStream,
	isURLSearchParams,
	isTypedArray,
	isFileList,
	forEach,
	merge: merge$1,
	extend,
	trim,
	stripBOM,
	inherits,
	toFlatObject,
	kindOf,
	kindOfTest,
	endsWith,
	toArray,
	forEachEntry,
	matchAll,
	isHTMLForm,
	hasOwnProperty: hasOwnProperty$3,
	hasOwnProp: hasOwnProperty$3,
	reduceDescriptors,
	freezeMethods,
	toObjectSet,
	toCamelCase,
	noop: noop$2,
	toFiniteNumber,
	findKey,
	global: _global,
	isContextDefined,
	isSpecCompliantForm,
	toJSONObject,
	isAsyncFn,
	isThenable,
	setImmediate: _setImmediate,
	asap,
	isIterable
};

//#endregion
//#region node_modules/axios/lib/core/AxiosError.js
var AxiosError$1 = class AxiosError$1 extends Error {
	static from(error, code, config, request, response, customProps) {
		const axiosError = new AxiosError$1(error.message, code || error.code, config, request, response);
		axiosError.cause = error;
		axiosError.name = error.name;
		customProps && Object.assign(axiosError, customProps);
		return axiosError;
	}
	/**
	* Create an Error with the specified message, config, error code, request and response.
	*
	* @param {string} message The error message.
	* @param {string} [code] The error code (for example, 'ECONNABORTED').
	* @param {Object} [config] The config.
	* @param {Object} [request] The request.
	* @param {Object} [response] The response.
	*
	* @returns {Error} The created error.
	*/
	constructor(message, code, config, request, response) {
		super(message);
		this.name = "AxiosError";
		this.isAxiosError = true;
		code && (this.code = code);
		config && (this.config = config);
		request && (this.request = request);
		if (response) {
			this.response = response;
			this.status = response.status;
		}
	}
	toJSON() {
		return {
			message: this.message,
			name: this.name,
			description: this.description,
			number: this.number,
			fileName: this.fileName,
			lineNumber: this.lineNumber,
			columnNumber: this.columnNumber,
			stack: this.stack,
			config: utils_default.toJSONObject(this.config),
			code: this.code,
			status: this.status
		};
	}
};
AxiosError$1.ERR_BAD_OPTION_VALUE = "ERR_BAD_OPTION_VALUE";
AxiosError$1.ERR_BAD_OPTION = "ERR_BAD_OPTION";
AxiosError$1.ECONNABORTED = "ECONNABORTED";
AxiosError$1.ETIMEDOUT = "ETIMEDOUT";
AxiosError$1.ERR_NETWORK = "ERR_NETWORK";
AxiosError$1.ERR_FR_TOO_MANY_REDIRECTS = "ERR_FR_TOO_MANY_REDIRECTS";
AxiosError$1.ERR_DEPRECATED = "ERR_DEPRECATED";
AxiosError$1.ERR_BAD_RESPONSE = "ERR_BAD_RESPONSE";
AxiosError$1.ERR_BAD_REQUEST = "ERR_BAD_REQUEST";
AxiosError$1.ERR_CANCELED = "ERR_CANCELED";
AxiosError$1.ERR_NOT_SUPPORT = "ERR_NOT_SUPPORT";
AxiosError$1.ERR_INVALID_URL = "ERR_INVALID_URL";
var AxiosError_default = AxiosError$1;

//#endregion
//#region node_modules/axios/lib/helpers/null.js
var null_default = null;

//#endregion
//#region node_modules/axios/lib/helpers/toFormData.js
/**
* Determines if the given thing is a array or js object.
*
* @param {string} thing - The object or array to be visited.
*
* @returns {boolean}
*/
function isVisitable(thing) {
	return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
/**
* It removes the brackets from the end of a string
*
* @param {string} key - The key of the parameter.
*
* @returns {string} the key without the brackets.
*/
function removeBrackets(key) {
	return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
/**
* It takes a path, a key, and a boolean, and returns a string
*
* @param {string} path - The path to the current key.
* @param {string} key - The key of the current object being iterated over.
* @param {string} dots - If true, the key will be rendered with dots instead of brackets.
*
* @returns {string} The path to the current key.
*/
function renderKey(path, key, dots) {
	if (!path) return key;
	return path.concat(key).map(function each(token, i) {
		token = removeBrackets(token);
		return !dots && i ? "[" + token + "]" : token;
	}).join(dots ? "." : "");
}
/**
* If the array is an array and none of its elements are visitable, then it's a flat array.
*
* @param {Array<any>} arr - The array to check
*
* @returns {boolean}
*/
function isFlatArray(arr) {
	return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
	return /^is[A-Z]/.test(prop);
});
/**
* Convert a data object to FormData
*
* @param {Object} obj
* @param {?Object} [formData]
* @param {?Object} [options]
* @param {Function} [options.visitor]
* @param {Boolean} [options.metaTokens = true]
* @param {Boolean} [options.dots = false]
* @param {?Boolean} [options.indexes = false]
*
* @returns {Object}
**/
/**
* It converts an object into a FormData object
*
* @param {Object<any, any>} obj - The object to convert to form data.
* @param {string} formData - The FormData object to append to.
* @param {Object<string, any>} options
*
* @returns
*/
function toFormData$1(obj, formData, options) {
	if (!utils_default.isObject(obj)) throw new TypeError("target must be an object");
	formData = formData || new (null_default || FormData)();
	options = utils_default.toFlatObject(options, {
		metaTokens: true,
		dots: false,
		indexes: false
	}, false, function defined(option, source) {
		return !utils_default.isUndefined(source[option]);
	});
	const metaTokens = options.metaTokens;
	const visitor = options.visitor || defaultVisitor;
	const dots = options.dots;
	const indexes = options.indexes;
	const useBlob = (options.Blob || typeof Blob !== "undefined" && Blob) && utils_default.isSpecCompliantForm(formData);
	if (!utils_default.isFunction(visitor)) throw new TypeError("visitor must be a function");
	function convertValue(value) {
		if (value === null) return "";
		if (utils_default.isDate(value)) return value.toISOString();
		if (utils_default.isBoolean(value)) return value.toString();
		if (!useBlob && utils_default.isBlob(value)) throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
		if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
		return value;
	}
	/**
	* Default visitor.
	*
	* @param {*} value
	* @param {String|Number} key
	* @param {Array<String|Number>} path
	* @this {FormData}
	*
	* @returns {boolean} return true to visit the each prop of the value recursively
	*/
	function defaultVisitor(value, key, path) {
		let arr = value;
		if (value && !path && typeof value === "object") {
			if (utils_default.endsWith(key, "{}")) {
				key = metaTokens ? key : key.slice(0, -2);
				value = JSON.stringify(value);
			} else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
				key = removeBrackets(key);
				arr.forEach(function each(el, index$1) {
					!(utils_default.isUndefined(el) || el === null) && formData.append(indexes === true ? renderKey([key], index$1, dots) : indexes === null ? key : key + "[]", convertValue(el));
				});
				return false;
			}
		}
		if (isVisitable(value)) return true;
		formData.append(renderKey(path, key, dots), convertValue(value));
		return false;
	}
	const stack = [];
	const exposedHelpers = Object.assign(predicates, {
		defaultVisitor,
		convertValue,
		isVisitable
	});
	function build(value, path) {
		if (utils_default.isUndefined(value)) return;
		if (stack.indexOf(value) !== -1) throw Error("Circular reference detected in " + path.join("."));
		stack.push(value);
		utils_default.forEach(value, function each(el, key) {
			if ((!(utils_default.isUndefined(el) || el === null) && visitor.call(formData, el, utils_default.isString(key) ? key.trim() : key, path, exposedHelpers)) === true) build(el, path ? path.concat(key) : [key]);
		});
		stack.pop();
	}
	if (!utils_default.isObject(obj)) throw new TypeError("data must be an object");
	build(obj);
	return formData;
}
var toFormData_default = toFormData$1;

//#endregion
//#region node_modules/axios/lib/helpers/AxiosURLSearchParams.js
/**
* It encodes a string by replacing all characters that are not in the unreserved set with
* their percent-encoded equivalents
*
* @param {string} str - The string to encode.
*
* @returns {string} The encoded string.
*/
function encode$2(str) {
	const charMap = {
		"!": "%21",
		"'": "%27",
		"(": "%28",
		")": "%29",
		"~": "%7E",
		"%20": "+",
		"%00": "\0"
	};
	return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
		return charMap[match];
	});
}
/**
* It takes a params object and converts it to a FormData object
*
* @param {Object<string, any>} params - The parameters to be converted to a FormData object.
* @param {Object<string, any>} options - The options object passed to the Axios constructor.
*
* @returns {void}
*/
function AxiosURLSearchParams(params, options) {
	this._pairs = [];
	params && toFormData_default(params, this, options);
}
var prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
	this._pairs.push([name, value]);
};
prototype.toString = function toString$1(encoder) {
	const _encode = encoder ? function(value) {
		return encoder.call(this, value, encode$2);
	} : encode$2;
	return this._pairs.map(function each(pair) {
		return _encode(pair[0]) + "=" + _encode(pair[1]);
	}, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

//#endregion
//#region node_modules/axios/lib/helpers/buildURL.js
/**
* It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
* URI encoded counterparts
*
* @param {string} val The value to be encoded.
*
* @returns {string} The encoded value.
*/
function encode$1(val) {
	return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
/**
* Build a URL by appending params to the end
*
* @param {string} url The base of the url (e.g., http://www.google.com)
* @param {object} [params] The params to be appended
* @param {?(object|Function)} options
*
* @returns {string} The formatted url
*/
function buildURL(url, params, options) {
	if (!params) return url;
	const _encode = options && options.encode || encode$1;
	const _options = utils_default.isFunction(options) ? { serialize: options } : options;
	const serializeFn = _options && _options.serialize;
	let serializedParams;
	if (serializeFn) serializedParams = serializeFn(params, _options);
	else serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, _options).toString(_encode);
	if (serializedParams) {
		const hashmarkIndex = url.indexOf("#");
		if (hashmarkIndex !== -1) url = url.slice(0, hashmarkIndex);
		url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
	}
	return url;
}

//#endregion
//#region node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
	constructor() {
		this.handlers = [];
	}
	/**
	* Add a new interceptor to the stack
	*
	* @param {Function} fulfilled The function to handle `then` for a `Promise`
	* @param {Function} rejected The function to handle `reject` for a `Promise`
	* @param {Object} options The options for the interceptor, synchronous and runWhen
	*
	* @return {Number} An ID used to remove interceptor later
	*/
	use(fulfilled, rejected, options) {
		this.handlers.push({
			fulfilled,
			rejected,
			synchronous: options ? options.synchronous : false,
			runWhen: options ? options.runWhen : null
		});
		return this.handlers.length - 1;
	}
	/**
	* Remove an interceptor from the stack
	*
	* @param {Number} id The ID that was returned by `use`
	*
	* @returns {void}
	*/
	eject(id) {
		if (this.handlers[id]) this.handlers[id] = null;
	}
	/**
	* Clear all interceptors from the stack
	*
	* @returns {void}
	*/
	clear() {
		if (this.handlers) this.handlers = [];
	}
	/**
	* Iterate over all the registered interceptors
	*
	* This method is particularly useful for skipping over any
	* interceptors that may have become `null` calling `eject`.
	*
	* @param {Function} fn The function to call for each interceptor
	*
	* @returns {void}
	*/
	forEach(fn) {
		utils_default.forEach(this.handlers, function forEachHandler(h) {
			if (h !== null) fn(h);
		});
	}
};
var InterceptorManager_default = InterceptorManager;

//#endregion
//#region node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
	silentJSONParsing: true,
	forcedJSONParsing: true,
	clarifyTimeoutError: false
};

//#endregion
//#region node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

//#endregion
//#region node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

//#endregion
//#region node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

//#endregion
//#region node_modules/axios/lib/platform/browser/index.js
var browser_default = {
	isBrowser: true,
	classes: {
		URLSearchParams: URLSearchParams_default,
		FormData: FormData_default,
		Blob: Blob_default
	},
	protocols: [
		"http",
		"https",
		"file",
		"blob",
		"url",
		"data"
	]
};

//#endregion
//#region node_modules/axios/lib/platform/common/utils.js
var utils_exports = /* @__PURE__ */ __export({
	hasBrowserEnv: () => hasBrowserEnv,
	hasStandardBrowserEnv: () => hasStandardBrowserEnv,
	hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
	navigator: () => _navigator,
	origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
/**
* Determine if we're running in a standard browser environment
*
* This allows axios to run in a web worker, and react-native.
* Both environments support XMLHttpRequest, but not fully standard globals.
*
* web workers:
*  typeof window -> undefined
*  typeof document -> undefined
*
* react-native:
*  navigator.product -> 'ReactNative'
* nativescript
*  navigator.product -> 'NativeScript' or 'NS'
*
* @returns {boolean}
*/
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || [
	"ReactNative",
	"NativeScript",
	"NS"
].indexOf(_navigator.product) < 0);
/**
* Determine if we're running in a standard browser webWorker environment
*
* Although the `isStandardBrowserEnv` method indicates that
* `allows axios to run in a web worker`, the WebWorker will still be
* filtered out due to its judgment standard
* `typeof window !== 'undefined' && typeof document !== 'undefined'`.
* This leads to a problem when axios post `FormData` in webWorker
*/
var hasStandardBrowserWebWorkerEnv = (() => {
	return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

//#endregion
//#region node_modules/axios/lib/platform/index.js
var platform_default = {
	...utils_exports,
	...browser_default
};

//#endregion
//#region node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
	return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
		visitor: function(value, key, path, helpers) {
			if (platform_default.isNode && utils_default.isBuffer(value)) {
				this.append(key, value.toString("base64"));
				return false;
			}
			return helpers.defaultVisitor.apply(this, arguments);
		},
		...options
	});
}

//#endregion
//#region node_modules/axios/lib/helpers/formDataToJSON.js
/**
* It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
*
* @param {string} name - The name of the property to get.
*
* @returns An array of strings.
*/
function parsePropPath(name) {
	return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
		return match[0] === "[]" ? "" : match[1] || match[0];
	});
}
/**
* Convert an array to an object.
*
* @param {Array<any>} arr - The array to convert to an object.
*
* @returns An object with the same keys and values as the array.
*/
function arrayToObject$1(arr) {
	const obj = {};
	const keys = Object.keys(arr);
	let i;
	const len = keys.length;
	let key;
	for (i = 0; i < len; i++) {
		key = keys[i];
		obj[key] = arr[key];
	}
	return obj;
}
/**
* It takes a FormData object and returns a JavaScript object
*
* @param {string} formData The FormData object to convert to JSON.
*
* @returns {Object<string, any> | null} The converted object.
*/
function formDataToJSON(formData) {
	function buildPath(path, value, target, index$1) {
		let name = path[index$1++];
		if (name === "__proto__") return true;
		const isNumericKey = Number.isFinite(+name);
		const isLast = index$1 >= path.length;
		name = !name && utils_default.isArray(target) ? target.length : name;
		if (isLast) {
			if (utils_default.hasOwnProp(target, name)) target[name] = [target[name], value];
			else target[name] = value;
			return !isNumericKey;
		}
		if (!target[name] || !utils_default.isObject(target[name])) target[name] = [];
		if (buildPath(path, value, target[name], index$1) && utils_default.isArray(target[name])) target[name] = arrayToObject$1(target[name]);
		return !isNumericKey;
	}
	if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
		const obj = {};
		utils_default.forEachEntry(formData, (name, value) => {
			buildPath(parsePropPath(name), value, obj, 0);
		});
		return obj;
	}
	return null;
}
var formDataToJSON_default = formDataToJSON;

//#endregion
//#region node_modules/axios/lib/defaults/index.js
/**
* It takes a string, tries to parse it, and if it fails, it returns the stringified version
* of the input
*
* @param {any} rawValue - The value to be stringified.
* @param {Function} parser - A function that parses a string into a JavaScript object.
* @param {Function} encoder - A function that takes a value and returns a string.
*
* @returns {string} A stringified version of the rawValue.
*/
function stringifySafely(rawValue, parser, encoder) {
	if (utils_default.isString(rawValue)) try {
		(parser || JSON.parse)(rawValue);
		return utils_default.trim(rawValue);
	} catch (e) {
		if (e.name !== "SyntaxError") throw e;
	}
	return (encoder || JSON.stringify)(rawValue);
}
var defaults$2 = {
	transitional: transitional_default,
	adapter: [
		"xhr",
		"http",
		"fetch"
	],
	transformRequest: [function transformRequest(data, headers) {
		const contentType = headers.getContentType() || "";
		const hasJSONContentType = contentType.indexOf("application/json") > -1;
		const isObjectPayload = utils_default.isObject(data);
		if (isObjectPayload && utils_default.isHTMLForm(data)) data = new FormData(data);
		if (utils_default.isFormData(data)) return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
		if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) return data;
		if (utils_default.isArrayBufferView(data)) return data.buffer;
		if (utils_default.isURLSearchParams(data)) {
			headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
			return data.toString();
		}
		let isFileList$1;
		if (isObjectPayload) {
			if (contentType.indexOf("application/x-www-form-urlencoded") > -1) return toURLEncodedForm(data, this.formSerializer).toString();
			if ((isFileList$1 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
				const _FormData = this.env && this.env.FormData;
				return toFormData_default(isFileList$1 ? { "files[]": data } : data, _FormData && new _FormData(), this.formSerializer);
			}
		}
		if (isObjectPayload || hasJSONContentType) {
			headers.setContentType("application/json", false);
			return stringifySafely(data);
		}
		return data;
	}],
	transformResponse: [function transformResponse(data) {
		const transitional = this.transitional || defaults$2.transitional;
		const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
		const JSONRequested = this.responseType === "json";
		if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) return data;
		if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
			const strictJSONParsing = !(transitional && transitional.silentJSONParsing) && JSONRequested;
			try {
				return JSON.parse(data, this.parseReviver);
			} catch (e) {
				if (strictJSONParsing) {
					if (e.name === "SyntaxError") throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
					throw e;
				}
			}
		}
		return data;
	}],
	timeout: 0,
	xsrfCookieName: "XSRF-TOKEN",
	xsrfHeaderName: "X-XSRF-TOKEN",
	maxContentLength: -1,
	maxBodyLength: -1,
	env: {
		FormData: platform_default.classes.FormData,
		Blob: platform_default.classes.Blob
	},
	validateStatus: function validateStatus(status) {
		return status >= 200 && status < 300;
	},
	headers: { common: {
		"Accept": "application/json, text/plain, */*",
		"Content-Type": void 0
	} }
};
utils_default.forEach([
	"delete",
	"get",
	"head",
	"post",
	"put",
	"patch"
], (method) => {
	defaults$2.headers[method] = {};
});
var defaults_default = defaults$2;

//#endregion
//#region node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
	"age",
	"authorization",
	"content-length",
	"content-type",
	"etag",
	"expires",
	"from",
	"host",
	"if-modified-since",
	"if-unmodified-since",
	"last-modified",
	"location",
	"max-forwards",
	"proxy-authorization",
	"referer",
	"retry-after",
	"user-agent"
]);
/**
* Parse headers into an object
*
* ```
* Date: Wed, 27 Aug 2014 08:58:49 GMT
* Content-Type: application/json
* Connection: keep-alive
* Transfer-Encoding: chunked
* ```
*
* @param {String} rawHeaders Headers needing to be parsed
*
* @returns {Object} Headers parsed into an object
*/
var parseHeaders_default = (rawHeaders) => {
	const parsed = {};
	let key;
	let val;
	let i;
	rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
		i = line.indexOf(":");
		key = line.substring(0, i).trim().toLowerCase();
		val = line.substring(i + 1).trim();
		if (!key || parsed[key] && ignoreDuplicateOf[key]) return;
		if (key === "set-cookie") if (parsed[key]) parsed[key].push(val);
		else parsed[key] = [val];
		else parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
	});
	return parsed;
};

//#endregion
//#region node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
	return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
	if (value === false || value == null) return value;
	return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
	const tokens = Object.create(null);
	const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
	let match;
	while (match = tokensRE.exec(str)) tokens[match[1]] = match[2];
	return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
	if (utils_default.isFunction(filter)) return filter.call(this, value, header);
	if (isHeaderNameFilter) value = header;
	if (!utils_default.isString(value)) return;
	if (utils_default.isString(filter)) return value.indexOf(filter) !== -1;
	if (utils_default.isRegExp(filter)) return filter.test(value);
}
function formatHeader(header) {
	return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w$1, char, str) => {
		return char.toUpperCase() + str;
	});
}
function buildAccessors(obj, header) {
	const accessorName = utils_default.toCamelCase(" " + header);
	[
		"get",
		"set",
		"has"
	].forEach((methodName) => {
		Object.defineProperty(obj, methodName + accessorName, {
			value: function(arg1, arg2, arg3) {
				return this[methodName].call(this, header, arg1, arg2, arg3);
			},
			configurable: true
		});
	});
}
var AxiosHeaders$1 = class {
	constructor(headers) {
		headers && this.set(headers);
	}
	set(header, valueOrRewrite, rewrite) {
		const self$1 = this;
		function setHeader(_value, _header, _rewrite) {
			const lHeader = normalizeHeader(_header);
			if (!lHeader) throw new Error("header name must be a non-empty string");
			const key = utils_default.findKey(self$1, lHeader);
			if (!key || self$1[key] === void 0 || _rewrite === true || _rewrite === void 0 && self$1[key] !== false) self$1[key || _header] = normalizeValue(_value);
		}
		const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
		if (utils_default.isPlainObject(header) || header instanceof this.constructor) setHeaders(header, valueOrRewrite);
		else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) setHeaders(parseHeaders_default(header), valueOrRewrite);
		else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
			let obj = {}, dest, key;
			for (const entry of header) {
				if (!utils_default.isArray(entry)) throw TypeError("Object iterator must return a key-value pair");
				obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
			}
			setHeaders(obj, valueOrRewrite);
		} else header != null && setHeader(valueOrRewrite, header, rewrite);
		return this;
	}
	get(header, parser) {
		header = normalizeHeader(header);
		if (header) {
			const key = utils_default.findKey(this, header);
			if (key) {
				const value = this[key];
				if (!parser) return value;
				if (parser === true) return parseTokens(value);
				if (utils_default.isFunction(parser)) return parser.call(this, value, key);
				if (utils_default.isRegExp(parser)) return parser.exec(value);
				throw new TypeError("parser must be boolean|regexp|function");
			}
		}
	}
	has(header, matcher) {
		header = normalizeHeader(header);
		if (header) {
			const key = utils_default.findKey(this, header);
			return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
		}
		return false;
	}
	delete(header, matcher) {
		const self$1 = this;
		let deleted = false;
		function deleteHeader(_header) {
			_header = normalizeHeader(_header);
			if (_header) {
				const key = utils_default.findKey(self$1, _header);
				if (key && (!matcher || matchHeaderValue(self$1, self$1[key], key, matcher))) {
					delete self$1[key];
					deleted = true;
				}
			}
		}
		if (utils_default.isArray(header)) header.forEach(deleteHeader);
		else deleteHeader(header);
		return deleted;
	}
	clear(matcher) {
		const keys = Object.keys(this);
		let i = keys.length;
		let deleted = false;
		while (i--) {
			const key = keys[i];
			if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
				delete this[key];
				deleted = true;
			}
		}
		return deleted;
	}
	normalize(format) {
		const self$1 = this;
		const headers = {};
		utils_default.forEach(this, (value, header) => {
			const key = utils_default.findKey(headers, header);
			if (key) {
				self$1[key] = normalizeValue(value);
				delete self$1[header];
				return;
			}
			const normalized = format ? formatHeader(header) : String(header).trim();
			if (normalized !== header) delete self$1[header];
			self$1[normalized] = normalizeValue(value);
			headers[normalized] = true;
		});
		return this;
	}
	concat(...targets) {
		return this.constructor.concat(this, ...targets);
	}
	toJSON(asStrings) {
		const obj = Object.create(null);
		utils_default.forEach(this, (value, header) => {
			value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
		});
		return obj;
	}
	[Symbol.iterator]() {
		return Object.entries(this.toJSON())[Symbol.iterator]();
	}
	toString() {
		return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
	}
	getSetCookie() {
		return this.get("set-cookie") || [];
	}
	get [Symbol.toStringTag]() {
		return "AxiosHeaders";
	}
	static from(thing) {
		return thing instanceof this ? thing : new this(thing);
	}
	static concat(first, ...targets) {
		const computed = new this(first);
		targets.forEach((target) => computed.set(target));
		return computed;
	}
	static accessor(header) {
		const accessors = (this[$internals] = this[$internals] = { accessors: {} }).accessors;
		const prototype$1 = this.prototype;
		function defineAccessor(_header) {
			const lHeader = normalizeHeader(_header);
			if (!accessors[lHeader]) {
				buildAccessors(prototype$1, _header);
				accessors[lHeader] = true;
			}
		}
		utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
		return this;
	}
};
AxiosHeaders$1.accessor([
	"Content-Type",
	"Content-Length",
	"Accept",
	"Accept-Encoding",
	"User-Agent",
	"Authorization"
]);
utils_default.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
	let mapped = key[0].toUpperCase() + key.slice(1);
	return {
		get: () => value,
		set(headerValue) {
			this[mapped] = headerValue;
		}
	};
});
utils_default.freezeMethods(AxiosHeaders$1);
var AxiosHeaders_default = AxiosHeaders$1;

//#endregion
//#region node_modules/axios/lib/core/transformData.js
/**
* Transform the data for a request or a response
*
* @param {Array|Function} fns A single function or Array of functions
* @param {?Object} response The response object
*
* @returns {*} The resulting transformed data
*/
function transformData(fns, response) {
	const config = this || defaults_default;
	const context = response || config;
	const headers = AxiosHeaders_default.from(context.headers);
	let data = context.data;
	utils_default.forEach(fns, function transform(fn) {
		data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
	});
	headers.normalize();
	return data;
}

//#endregion
//#region node_modules/axios/lib/cancel/isCancel.js
function isCancel$1(value) {
	return !!(value && value.__CANCEL__);
}

//#endregion
//#region node_modules/axios/lib/cancel/CanceledError.js
var CanceledError$1 = class extends AxiosError_default {
	/**
	* A `CanceledError` is an object that is thrown when an operation is canceled.
	*
	* @param {string=} message The message.
	* @param {Object=} config The config.
	* @param {Object=} request The request.
	*
	* @returns {CanceledError} The created error.
	*/
	constructor(message, config, request) {
		super(message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
		this.name = "CanceledError";
		this.__CANCEL__ = true;
	}
};
var CanceledError_default = CanceledError$1;

//#endregion
//#region node_modules/axios/lib/core/settle.js
/**
* Resolve or reject a Promise based on response status.
*
* @param {Function} resolve A function that resolves the promise.
* @param {Function} reject A function that rejects the promise.
* @param {object} response The response.
*
* @returns {object} The response.
*/
function settle(resolve, reject, response) {
	const validateStatus = response.config.validateStatus;
	if (!response.status || !validateStatus || validateStatus(response.status)) resolve(response);
	else reject(new AxiosError_default("Request failed with status code " + response.status, [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
}

//#endregion
//#region node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
	const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
	return match && match[1] || "";
}

//#endregion
//#region node_modules/axios/lib/helpers/speedometer.js
/**
* Calculate data maxRate
* @param {Number} [samplesCount= 10]
* @param {Number} [min= 1000]
* @returns {Function}
*/
function speedometer(samplesCount, min$1) {
	samplesCount = samplesCount || 10;
	const bytes = new Array(samplesCount);
	const timestamps = new Array(samplesCount);
	let head = 0;
	let tail = 0;
	let firstSampleTS;
	min$1 = min$1 !== void 0 ? min$1 : 1e3;
	return function push$1(chunkLength) {
		const now = Date.now();
		const startedAt = timestamps[tail];
		if (!firstSampleTS) firstSampleTS = now;
		bytes[head] = chunkLength;
		timestamps[head] = now;
		let i = tail;
		let bytesCount = 0;
		while (i !== head) {
			bytesCount += bytes[i++];
			i = i % samplesCount;
		}
		head = (head + 1) % samplesCount;
		if (head === tail) tail = (tail + 1) % samplesCount;
		if (now - firstSampleTS < min$1) return;
		const passed = startedAt && now - startedAt;
		return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
	};
}
var speedometer_default = speedometer;

//#endregion
//#region node_modules/axios/lib/helpers/throttle.js
/**
* Throttle decorator
* @param {Function} fn
* @param {Number} freq
* @return {Function}
*/
function throttle(fn, freq) {
	let timestamp = 0;
	let threshold = 1e3 / freq;
	let lastArgs;
	let timer;
	const invoke = (args, now = Date.now()) => {
		timestamp = now;
		lastArgs = null;
		if (timer) {
			clearTimeout(timer);
			timer = null;
		}
		fn(...args);
	};
	const throttled = (...args) => {
		const now = Date.now();
		const passed = now - timestamp;
		if (passed >= threshold) invoke(args, now);
		else {
			lastArgs = args;
			if (!timer) timer = setTimeout(() => {
				timer = null;
				invoke(lastArgs);
			}, threshold - passed);
		}
	};
	const flush = () => lastArgs && invoke(lastArgs);
	return [throttled, flush];
}
var throttle_default = throttle;

//#endregion
//#region node_modules/axios/lib/helpers/progressEventReducer.js
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
	let bytesNotified = 0;
	const _speedometer = speedometer_default(50, 250);
	return throttle_default((e) => {
		const loaded = e.loaded;
		const total = e.lengthComputable ? e.total : void 0;
		const progressBytes = loaded - bytesNotified;
		const rate = _speedometer(progressBytes);
		const inRange = loaded <= total;
		bytesNotified = loaded;
		listener({
			loaded,
			total,
			progress: total ? loaded / total : void 0,
			bytes: progressBytes,
			rate: rate ? rate : void 0,
			estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
			event: e,
			lengthComputable: total != null,
			[isDownloadStream ? "download" : "upload"]: true
		});
	}, freq);
};
const progressEventDecorator = (total, throttled) => {
	const lengthComputable = total != null;
	return [(loaded) => throttled[0]({
		lengthComputable,
		total,
		loaded
	}), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

//#endregion
//#region node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? ((origin$1, isMSIE) => (url) => {
	url = new URL(url, platform_default.origin);
	return origin$1.protocol === url.protocol && origin$1.host === url.host && (isMSIE || origin$1.port === url.port);
})(new URL(platform_default.origin), platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)) : () => true;

//#endregion
//#region node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? {
	write(name, value, expires, path, domain, secure, sameSite) {
		if (typeof document === "undefined") return;
		const cookie = [`${name}=${encodeURIComponent(value)}`];
		if (utils_default.isNumber(expires)) cookie.push(`expires=${new Date(expires).toUTCString()}`);
		if (utils_default.isString(path)) cookie.push(`path=${path}`);
		if (utils_default.isString(domain)) cookie.push(`domain=${domain}`);
		if (secure === true) cookie.push("secure");
		if (utils_default.isString(sameSite)) cookie.push(`SameSite=${sameSite}`);
		document.cookie = cookie.join("; ");
	},
	read(name) {
		if (typeof document === "undefined") return null;
		const match = document.cookie.match(/* @__PURE__ */ new RegExp("(?:^|; )" + name + "=([^;]*)"));
		return match ? decodeURIComponent(match[1]) : null;
	},
	remove(name) {
		this.write(name, "", Date.now() - 864e5, "/");
	}
} : {
	write() {},
	read() {
		return null;
	},
	remove() {}
};

//#endregion
//#region node_modules/axios/lib/helpers/isAbsoluteURL.js
/**
* Determines whether the specified URL is absolute
*
* @param {string} url The URL to test
*
* @returns {boolean} True if the specified URL is absolute, otherwise false
*/
function isAbsoluteURL(url) {
	return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

//#endregion
//#region node_modules/axios/lib/helpers/combineURLs.js
/**
* Creates a new URL by combining the specified URLs
*
* @param {string} baseURL The base URL
* @param {string} relativeURL The relative URL
*
* @returns {string} The combined URL
*/
function combineURLs(baseURL, relativeURL) {
	return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

//#endregion
//#region node_modules/axios/lib/core/buildFullPath.js
/**
* Creates a new URL by combining the baseURL with the requestedURL,
* only when the requestedURL is not already an absolute URL.
* If the requestURL is absolute, this function returns the requestedURL untouched.
*
* @param {string} baseURL The base URL
* @param {string} requestedURL Absolute or relative URL to combine
*
* @returns {string} The combined full path
*/
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
	let isRelativeUrl = !isAbsoluteURL(requestedURL);
	if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) return combineURLs(baseURL, requestedURL);
	return requestedURL;
}

//#endregion
//#region node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
/**
* Config-specific merge-function which creates a new config-object
* by merging two configuration objects together.
*
* @param {Object} config1
* @param {Object} config2
*
* @returns {Object} New object resulting from merging config2 to config1
*/
function mergeConfig$1(config1, config2) {
	config2 = config2 || {};
	const config = {};
	function getMergedValue(target, source, prop, caseless) {
		if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) return utils_default.merge.call({ caseless }, target, source);
		else if (utils_default.isPlainObject(source)) return utils_default.merge({}, source);
		else if (utils_default.isArray(source)) return source.slice();
		return source;
	}
	function mergeDeepProperties(a, b$1, prop, caseless) {
		if (!utils_default.isUndefined(b$1)) return getMergedValue(a, b$1, prop, caseless);
		else if (!utils_default.isUndefined(a)) return getMergedValue(void 0, a, prop, caseless);
	}
	function valueFromConfig2(a, b$1) {
		if (!utils_default.isUndefined(b$1)) return getMergedValue(void 0, b$1);
	}
	function defaultToConfig2(a, b$1) {
		if (!utils_default.isUndefined(b$1)) return getMergedValue(void 0, b$1);
		else if (!utils_default.isUndefined(a)) return getMergedValue(void 0, a);
	}
	function mergeDirectKeys(a, b$1, prop) {
		if (prop in config2) return getMergedValue(a, b$1);
		else if (prop in config1) return getMergedValue(void 0, a);
	}
	const mergeMap = {
		url: valueFromConfig2,
		method: valueFromConfig2,
		data: valueFromConfig2,
		baseURL: defaultToConfig2,
		transformRequest: defaultToConfig2,
		transformResponse: defaultToConfig2,
		paramsSerializer: defaultToConfig2,
		timeout: defaultToConfig2,
		timeoutMessage: defaultToConfig2,
		withCredentials: defaultToConfig2,
		withXSRFToken: defaultToConfig2,
		adapter: defaultToConfig2,
		responseType: defaultToConfig2,
		xsrfCookieName: defaultToConfig2,
		xsrfHeaderName: defaultToConfig2,
		onUploadProgress: defaultToConfig2,
		onDownloadProgress: defaultToConfig2,
		decompress: defaultToConfig2,
		maxContentLength: defaultToConfig2,
		maxBodyLength: defaultToConfig2,
		beforeRedirect: defaultToConfig2,
		transport: defaultToConfig2,
		httpAgent: defaultToConfig2,
		httpsAgent: defaultToConfig2,
		cancelToken: defaultToConfig2,
		socketPath: defaultToConfig2,
		responseEncoding: defaultToConfig2,
		validateStatus: mergeDirectKeys,
		headers: (a, b$1, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b$1), prop, true)
	};
	utils_default.forEach(Object.keys({
		...config1,
		...config2
	}), function computeConfigValue(prop) {
		const merge$2 = mergeMap[prop] || mergeDeepProperties;
		const configValue = merge$2(config1[prop], config2[prop], prop);
		utils_default.isUndefined(configValue) && merge$2 !== mergeDirectKeys || (config[prop] = configValue);
	});
	return config;
}

//#endregion
//#region node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
	const newConfig = mergeConfig$1({}, config);
	let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
	newConfig.headers = headers = AxiosHeaders_default.from(headers);
	newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
	if (auth) headers.set("Authorization", "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : "")));
	if (utils_default.isFormData(data)) {
		if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) headers.setContentType(void 0);
		else if (utils_default.isFunction(data.getHeaders)) {
			const formHeaders = data.getHeaders();
			const allowedHeaders = ["content-type", "content-length"];
			Object.entries(formHeaders).forEach(([key, val]) => {
				if (allowedHeaders.includes(key.toLowerCase())) headers.set(key, val);
			});
		}
	}
	if (platform_default.hasStandardBrowserEnv) {
		withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
		if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
			const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
			if (xsrfValue) headers.set(xsrfHeaderName, xsrfValue);
		}
	}
	return newConfig;
};

//#endregion
//#region node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
	return new Promise(function dispatchXhrRequest(resolve, reject) {
		const _config = resolveConfig_default(config);
		let requestData = _config.data;
		const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
		let { responseType, onUploadProgress, onDownloadProgress } = _config;
		let onCanceled;
		let uploadThrottled, downloadThrottled;
		let flushUpload, flushDownload;
		function done() {
			flushUpload && flushUpload();
			flushDownload && flushDownload();
			_config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
			_config.signal && _config.signal.removeEventListener("abort", onCanceled);
		}
		let request = new XMLHttpRequest();
		request.open(_config.method.toUpperCase(), _config.url, true);
		request.timeout = _config.timeout;
		function onloadend() {
			if (!request) return;
			const responseHeaders = AxiosHeaders_default.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
			settle(function _resolve(value) {
				resolve(value);
				done();
			}, function _reject(err) {
				reject(err);
				done();
			}, {
				data: !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response,
				status: request.status,
				statusText: request.statusText,
				headers: responseHeaders,
				config,
				request
			});
			request = null;
		}
		if ("onloadend" in request) request.onloadend = onloadend;
		else request.onreadystatechange = function handleLoad() {
			if (!request || request.readyState !== 4) return;
			if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) return;
			setTimeout(onloadend);
		};
		request.onabort = function handleAbort() {
			if (!request) return;
			reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
			request = null;
		};
		request.onerror = function handleError(event) {
			const err = new AxiosError_default(event && event.message ? event.message : "Network Error", AxiosError_default.ERR_NETWORK, config, request);
			err.event = event || null;
			reject(err);
			request = null;
		};
		request.ontimeout = function handleTimeout() {
			let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
			const transitional = _config.transitional || transitional_default;
			if (_config.timeoutErrorMessage) timeoutErrorMessage = _config.timeoutErrorMessage;
			reject(new AxiosError_default(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, request));
			request = null;
		};
		requestData === void 0 && requestHeaders.setContentType(null);
		if ("setRequestHeader" in request) utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
			request.setRequestHeader(key, val);
		});
		if (!utils_default.isUndefined(_config.withCredentials)) request.withCredentials = !!_config.withCredentials;
		if (responseType && responseType !== "json") request.responseType = _config.responseType;
		if (onDownloadProgress) {
			[downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
			request.addEventListener("progress", downloadThrottled);
		}
		if (onUploadProgress && request.upload) {
			[uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
			request.upload.addEventListener("progress", uploadThrottled);
			request.upload.addEventListener("loadend", flushUpload);
		}
		if (_config.cancelToken || _config.signal) {
			onCanceled = (cancel) => {
				if (!request) return;
				reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
				request.abort();
				request = null;
			};
			_config.cancelToken && _config.cancelToken.subscribe(onCanceled);
			if (_config.signal) _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
		}
		const protocol = parseProtocol(_config.url);
		if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
			reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
			return;
		}
		request.send(requestData || null);
	});
};

//#endregion
//#region node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
	const { length } = signals = signals ? signals.filter(Boolean) : [];
	if (timeout || length) {
		let controller = new AbortController();
		let aborted;
		const onabort = function(reason) {
			if (!aborted) {
				aborted = true;
				unsubscribe();
				const err = reason instanceof Error ? reason : this.reason;
				controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
			}
		};
		let timer = timeout && setTimeout(() => {
			timer = null;
			onabort(new AxiosError_default(`timeout of ${timeout}ms exceeded`, AxiosError_default.ETIMEDOUT));
		}, timeout);
		const unsubscribe = () => {
			if (signals) {
				timer && clearTimeout(timer);
				timer = null;
				signals.forEach((signal$1) => {
					signal$1.unsubscribe ? signal$1.unsubscribe(onabort) : signal$1.removeEventListener("abort", onabort);
				});
				signals = null;
			}
		};
		signals.forEach((signal$1) => signal$1.addEventListener("abort", onabort));
		const { signal } = controller;
		signal.unsubscribe = () => utils_default.asap(unsubscribe);
		return signal;
	}
};
var composeSignals_default = composeSignals;

//#endregion
//#region node_modules/axios/lib/helpers/trackStream.js
const streamChunk = function* (chunk, chunkSize) {
	let len = chunk.byteLength;
	if (!chunkSize || len < chunkSize) {
		yield chunk;
		return;
	}
	let pos = 0;
	let end;
	while (pos < len) {
		end = pos + chunkSize;
		yield chunk.slice(pos, end);
		pos = end;
	}
};
const readBytes = async function* (iterable, chunkSize) {
	for await (const chunk of readStream(iterable)) yield* streamChunk(chunk, chunkSize);
};
var readStream = async function* (stream) {
	if (stream[Symbol.asyncIterator]) {
		yield* stream;
		return;
	}
	const reader = stream.getReader();
	try {
		for (;;) {
			const { done, value } = await reader.read();
			if (done) break;
			yield value;
		}
	} finally {
		await reader.cancel();
	}
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
	const iterator$1 = readBytes(stream, chunkSize);
	let bytes = 0;
	let done;
	let _onFinish = (e) => {
		if (!done) {
			done = true;
			onFinish && onFinish(e);
		}
	};
	return new ReadableStream({
		async pull(controller) {
			try {
				const { done: done$1, value } = await iterator$1.next();
				if (done$1) {
					_onFinish();
					controller.close();
					return;
				}
				let len = value.byteLength;
				if (onProgress) onProgress(bytes += len);
				controller.enqueue(new Uint8Array(value));
			} catch (err) {
				_onFinish(err);
				throw err;
			}
		},
		cancel(reason) {
			_onFinish(reason);
			return iterator$1.return();
		}
	}, { highWaterMark: 2 });
};

//#endregion
//#region node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var { isFunction } = utils_default;
var globalFetchAPI = (({ Request, Response }) => ({
	Request,
	Response
}))(utils_default.global);
var { ReadableStream: ReadableStream$1, TextEncoder } = utils_default.global;
var test = (fn, ...args) => {
	try {
		return !!fn(...args);
	} catch (e) {
		return false;
	}
};
var factory = (env) => {
	env = utils_default.merge.call({ skipUndefined: true }, globalFetchAPI, env);
	const { fetch: envFetch, Request, Response } = env;
	const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
	const isRequestSupported = isFunction(Request);
	const isResponseSupported = isFunction(Response);
	if (!isFetchSupported) return false;
	const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
	const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
	const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
		let duplexAccessed = false;
		const hasContentType = new Request(platform_default.origin, {
			body: new ReadableStream$1(),
			method: "POST",
			get duplex() {
				duplexAccessed = true;
				return "half";
			}
		}).headers.has("Content-Type");
		return duplexAccessed && !hasContentType;
	});
	const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
	const resolvers = { stream: supportsResponseStream && ((res) => res.body) };
	isFetchSupported && [
		"text",
		"arrayBuffer",
		"blob",
		"formData",
		"stream"
	].forEach((type) => {
		!resolvers[type] && (resolvers[type] = (res, config) => {
			let method = res && res[type];
			if (method) return method.call(res);
			throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
		});
	});
	const getBodyLength = async (body) => {
		if (body == null) return 0;
		if (utils_default.isBlob(body)) return body.size;
		if (utils_default.isSpecCompliantForm(body)) return (await new Request(platform_default.origin, {
			method: "POST",
			body
		}).arrayBuffer()).byteLength;
		if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) return body.byteLength;
		if (utils_default.isURLSearchParams(body)) body = body + "";
		if (utils_default.isString(body)) return (await encodeText(body)).byteLength;
	};
	const resolveBodyLength = async (headers, body) => {
		const length = utils_default.toFiniteNumber(headers.getContentLength());
		return length == null ? getBodyLength(body) : length;
	};
	return async (config) => {
		let { url, method, data, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, withCredentials = "same-origin", fetchOptions } = resolveConfig_default(config);
		let _fetch = envFetch || fetch;
		responseType = responseType ? (responseType + "").toLowerCase() : "text";
		let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
		let request = null;
		const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
			composedSignal.unsubscribe();
		});
		let requestContentLength;
		try {
			if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
				let _request = new Request(url, {
					method: "POST",
					body: data,
					duplex: "half"
				});
				let contentTypeHeader;
				if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) headers.setContentType(contentTypeHeader);
				if (_request.body) {
					const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));
					data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
				}
			}
			if (!utils_default.isString(withCredentials)) withCredentials = withCredentials ? "include" : "omit";
			const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
			const resolvedOptions = {
				...fetchOptions,
				signal: composedSignal,
				method: method.toUpperCase(),
				headers: headers.normalize().toJSON(),
				body: data,
				duplex: "half",
				credentials: isCredentialsSupported ? withCredentials : void 0
			};
			request = isRequestSupported && new Request(url, resolvedOptions);
			let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
			const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
			if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
				const options = {};
				[
					"status",
					"statusText",
					"headers"
				].forEach((prop) => {
					options[prop] = response[prop];
				});
				const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
				const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];
				response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
					flush && flush();
					unsubscribe && unsubscribe();
				}), options);
			}
			responseType = responseType || "text";
			let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
			!isStreamResponse && unsubscribe && unsubscribe();
			return await new Promise((resolve, reject) => {
				settle(resolve, reject, {
					data: responseData,
					headers: AxiosHeaders_default.from(response.headers),
					status: response.status,
					statusText: response.statusText,
					config,
					request
				});
			});
		} catch (err) {
			unsubscribe && unsubscribe();
			if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) throw Object.assign(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request), { cause: err.cause || err });
			throw AxiosError_default.from(err, err && err.code, config, request);
		}
	};
};
var seedCache = /* @__PURE__ */ new Map();
const getFetch = (config) => {
	let env = config && config.env || {};
	const { fetch: fetch$1, Request, Response } = env;
	const seeds = [
		Request,
		Response,
		fetch$1
	];
	let i = seeds.length, seed, target, map = seedCache;
	while (i--) {
		seed = seeds[i];
		target = map.get(seed);
		target === void 0 && map.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env));
		map = target;
	}
	return target;
};
var adapter = getFetch();

//#endregion
//#region node_modules/axios/lib/adapters/adapters.js
/**
* Known adapters mapping.
* Provides environment-specific adapters for Axios:
* - `http` for Node.js
* - `xhr` for browsers
* - `fetch` for fetch API-based requests
* 
* @type {Object<string, Function|Object>}
*/
var knownAdapters = {
	http: null_default,
	xhr: xhr_default,
	fetch: { get: getFetch }
};
utils_default.forEach(knownAdapters, (fn, value) => {
	if (fn) {
		try {
			Object.defineProperty(fn, "name", { value });
		} catch (e) {}
		Object.defineProperty(fn, "adapterName", { value });
	}
});
/**
* Render a rejection reason string for unknown or unsupported adapters
* 
* @param {string} reason
* @returns {string}
*/
var renderReason = (reason) => `- ${reason}`;
/**
* Check if the adapter is resolved (function, null, or false)
* 
* @param {Function|null|false} adapter
* @returns {boolean}
*/
var isResolvedHandle = (adapter$1) => utils_default.isFunction(adapter$1) || adapter$1 === null || adapter$1 === false;
/**
* Get the first suitable adapter from the provided list.
* Tries each adapter in order until a supported one is found.
* Throws an AxiosError if no adapter is suitable.
* 
* @param {Array<string|Function>|string|Function} adapters - Adapter(s) by name or function.
* @param {Object} config - Axios request configuration
* @throws {AxiosError} If no suitable adapter is available
* @returns {Function} The resolved adapter function
*/
function getAdapter$1(adapters, config) {
	adapters = utils_default.isArray(adapters) ? adapters : [adapters];
	const { length } = adapters;
	let nameOrAdapter;
	let adapter$1;
	const rejectedReasons = {};
	for (let i = 0; i < length; i++) {
		nameOrAdapter = adapters[i];
		let id;
		adapter$1 = nameOrAdapter;
		if (!isResolvedHandle(nameOrAdapter)) {
			adapter$1 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
			if (adapter$1 === void 0) throw new AxiosError_default(`Unknown adapter '${id}'`);
		}
		if (adapter$1 && (utils_default.isFunction(adapter$1) || (adapter$1 = adapter$1.get(config)))) break;
		rejectedReasons[id || "#" + i] = adapter$1;
	}
	if (!adapter$1) {
		const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
		throw new AxiosError_default(`There is no suitable adapter to dispatch the request ` + (length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT");
	}
	return adapter$1;
}
/**
* Exports Axios adapters and utility to resolve an adapter
*/
var adapters_default = {
	getAdapter: getAdapter$1,
	adapters: knownAdapters
};

//#endregion
//#region node_modules/axios/lib/core/dispatchRequest.js
/**
* Throws a `CanceledError` if cancellation has been requested.
*
* @param {Object} config The config that is to be used for the request
*
* @returns {void}
*/
function throwIfCancellationRequested(config) {
	if (config.cancelToken) config.cancelToken.throwIfRequested();
	if (config.signal && config.signal.aborted) throw new CanceledError_default(null, config);
}
/**
* Dispatch a request to the server using the configured adapter.
*
* @param {object} config The config that is to be used for the request
*
* @returns {Promise} The Promise to be fulfilled
*/
function dispatchRequest(config) {
	throwIfCancellationRequested(config);
	config.headers = AxiosHeaders_default.from(config.headers);
	config.data = transformData.call(config, config.transformRequest);
	if ([
		"post",
		"put",
		"patch"
	].indexOf(config.method) !== -1) config.headers.setContentType("application/x-www-form-urlencoded", false);
	return adapters_default.getAdapter(config.adapter || defaults_default.adapter, config)(config).then(function onAdapterResolution(response) {
		throwIfCancellationRequested(config);
		response.data = transformData.call(config, config.transformResponse, response);
		response.headers = AxiosHeaders_default.from(response.headers);
		return response;
	}, function onAdapterRejection(reason) {
		if (!isCancel$1(reason)) {
			throwIfCancellationRequested(config);
			if (reason && reason.response) {
				reason.response.data = transformData.call(config, config.transformResponse, reason.response);
				reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
			}
		}
		return Promise.reject(reason);
	});
}

//#endregion
//#region node_modules/axios/lib/env/data.js
const VERSION$1 = "1.13.4";

//#endregion
//#region node_modules/axios/lib/helpers/validator.js
var validators$1 = {};
[
	"object",
	"boolean",
	"number",
	"function",
	"string",
	"symbol"
].forEach((type, i) => {
	validators$1[type] = function validator(thing) {
		return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
	};
});
var deprecatedWarnings = {};
/**
* Transitional option validator
*
* @param {function|boolean?} validator - set to false if the transitional option has been removed
* @param {string?} version - deprecated version / removed since version
* @param {string?} message - some message with additional info
*
* @returns {function}
*/
validators$1.transitional = function transitional(validator, version, message) {
	function formatMessage(opt, desc$1) {
		return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc$1 + (message ? ". " + message : "");
	}
	return (value, opt, opts) => {
		if (validator === false) throw new AxiosError_default(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), AxiosError_default.ERR_DEPRECATED);
		if (version && !deprecatedWarnings[opt]) {
			deprecatedWarnings[opt] = true;
			console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
		}
		return validator ? validator(value, opt, opts) : true;
	};
};
validators$1.spelling = function spelling(correctSpelling) {
	return (value, opt) => {
		console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
		return true;
	};
};
/**
* Assert object's properties type
*
* @param {object} options
* @param {object} schema
* @param {boolean?} allowUnknown
*
* @returns {object}
*/
function assertOptions(options, schema, allowUnknown) {
	if (typeof options !== "object") throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
	const keys = Object.keys(options);
	let i = keys.length;
	while (i-- > 0) {
		const opt = keys[i];
		const validator = schema[opt];
		if (validator) {
			const value = options[opt];
			const result = value === void 0 || validator(value, opt, options);
			if (result !== true) throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
			continue;
		}
		if (allowUnknown !== true) throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
	}
}
var validator_default = {
	assertOptions,
	validators: validators$1
};

//#endregion
//#region node_modules/axios/lib/core/Axios.js
var validators = validator_default.validators;
/**
* Create a new instance of Axios
*
* @param {Object} instanceConfig The default config for the instance
*
* @return {Axios} A new instance of Axios
*/
var Axios$1 = class {
	constructor(instanceConfig) {
		this.defaults = instanceConfig || {};
		this.interceptors = {
			request: new InterceptorManager_default(),
			response: new InterceptorManager_default()
		};
	}
	/**
	* Dispatch a request
	*
	* @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
	* @param {?Object} config
	*
	* @returns {Promise} The Promise to be fulfilled
	*/
	async request(configOrUrl, config) {
		try {
			return await this._request(configOrUrl, config);
		} catch (err) {
			if (err instanceof Error) {
				let dummy = {};
				Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = /* @__PURE__ */ new Error();
				const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
				try {
					if (!err.stack) err.stack = stack;
					else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) err.stack += "\n" + stack;
				} catch (e) {}
			}
			throw err;
		}
	}
	_request(configOrUrl, config) {
		if (typeof configOrUrl === "string") {
			config = config || {};
			config.url = configOrUrl;
		} else config = configOrUrl || {};
		config = mergeConfig$1(this.defaults, config);
		const { transitional, paramsSerializer, headers } = config;
		if (transitional !== void 0) validator_default.assertOptions(transitional, {
			silentJSONParsing: validators.transitional(validators.boolean),
			forcedJSONParsing: validators.transitional(validators.boolean),
			clarifyTimeoutError: validators.transitional(validators.boolean)
		}, false);
		if (paramsSerializer != null) if (utils_default.isFunction(paramsSerializer)) config.paramsSerializer = { serialize: paramsSerializer };
		else validator_default.assertOptions(paramsSerializer, {
			encode: validators.function,
			serialize: validators.function
		}, true);
		if (config.allowAbsoluteUrls !== void 0) {} else if (this.defaults.allowAbsoluteUrls !== void 0) config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
		else config.allowAbsoluteUrls = true;
		validator_default.assertOptions(config, {
			baseUrl: validators.spelling("baseURL"),
			withXsrfToken: validators.spelling("withXSRFToken")
		}, true);
		config.method = (config.method || this.defaults.method || "get").toLowerCase();
		let contextHeaders = headers && utils_default.merge(headers.common, headers[config.method]);
		headers && utils_default.forEach([
			"delete",
			"get",
			"head",
			"post",
			"put",
			"patch",
			"common"
		], (method) => {
			delete headers[method];
		});
		config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
		const requestInterceptorChain = [];
		let synchronousRequestInterceptors = true;
		this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
			if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) return;
			synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
			requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
		});
		const responseInterceptorChain = [];
		this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
			responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
		});
		let promise;
		let i = 0;
		let len;
		if (!synchronousRequestInterceptors) {
			const chain = [dispatchRequest.bind(this), void 0];
			chain.unshift(...requestInterceptorChain);
			chain.push(...responseInterceptorChain);
			len = chain.length;
			promise = Promise.resolve(config);
			while (i < len) promise = promise.then(chain[i++], chain[i++]);
			return promise;
		}
		len = requestInterceptorChain.length;
		let newConfig = config;
		while (i < len) {
			const onFulfilled = requestInterceptorChain[i++];
			const onRejected = requestInterceptorChain[i++];
			try {
				newConfig = onFulfilled(newConfig);
			} catch (error) {
				onRejected.call(this, error);
				break;
			}
		}
		try {
			promise = dispatchRequest.call(this, newConfig);
		} catch (error) {
			return Promise.reject(error);
		}
		i = 0;
		len = responseInterceptorChain.length;
		while (i < len) promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
		return promise;
	}
	getUri(config) {
		config = mergeConfig$1(this.defaults, config);
		return buildURL(buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls), config.params, config.paramsSerializer);
	}
};
utils_default.forEach([
	"delete",
	"get",
	"head",
	"options"
], function forEachMethodNoData(method) {
	Axios$1.prototype[method] = function(url, config) {
		return this.request(mergeConfig$1(config || {}, {
			method,
			url,
			data: (config || {}).data
		}));
	};
});
utils_default.forEach([
	"post",
	"put",
	"patch"
], function forEachMethodWithData(method) {
	function generateHTTPMethod(isForm) {
		return function httpMethod(url, data, config) {
			return this.request(mergeConfig$1(config || {}, {
				method,
				headers: isForm ? { "Content-Type": "multipart/form-data" } : {},
				url,
				data
			}));
		};
	}
	Axios$1.prototype[method] = generateHTTPMethod();
	Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios$1;

//#endregion
//#region node_modules/axios/lib/cancel/CancelToken.js
/**
* A `CancelToken` is an object that can be used to request cancellation of an operation.
*
* @param {Function} executor The executor function.
*
* @returns {CancelToken}
*/
var CancelToken$1 = class CancelToken$1 {
	constructor(executor) {
		if (typeof executor !== "function") throw new TypeError("executor must be a function.");
		let resolvePromise;
		this.promise = new Promise(function promiseExecutor(resolve) {
			resolvePromise = resolve;
		});
		const token = this;
		this.promise.then((cancel) => {
			if (!token._listeners) return;
			let i = token._listeners.length;
			while (i-- > 0) token._listeners[i](cancel);
			token._listeners = null;
		});
		this.promise.then = (onfulfilled) => {
			let _resolve;
			const promise = new Promise((resolve) => {
				token.subscribe(resolve);
				_resolve = resolve;
			}).then(onfulfilled);
			promise.cancel = function reject() {
				token.unsubscribe(_resolve);
			};
			return promise;
		};
		executor(function cancel(message, config, request) {
			if (token.reason) return;
			token.reason = new CanceledError_default(message, config, request);
			resolvePromise(token.reason);
		});
	}
	/**
	* Throws a `CanceledError` if cancellation has been requested.
	*/
	throwIfRequested() {
		if (this.reason) throw this.reason;
	}
	/**
	* Subscribe to the cancel signal
	*/
	subscribe(listener) {
		if (this.reason) {
			listener(this.reason);
			return;
		}
		if (this._listeners) this._listeners.push(listener);
		else this._listeners = [listener];
	}
	/**
	* Unsubscribe from the cancel signal
	*/
	unsubscribe(listener) {
		if (!this._listeners) return;
		const index$1 = this._listeners.indexOf(listener);
		if (index$1 !== -1) this._listeners.splice(index$1, 1);
	}
	toAbortSignal() {
		const controller = new AbortController();
		const abort = (err) => {
			controller.abort(err);
		};
		this.subscribe(abort);
		controller.signal.unsubscribe = () => this.unsubscribe(abort);
		return controller.signal;
	}
	/**
	* Returns an object that contains a new `CancelToken` and a function that, when called,
	* cancels the `CancelToken`.
	*/
	static source() {
		let cancel;
		return {
			token: new CancelToken$1(function executor(c) {
				cancel = c;
			}),
			cancel
		};
	}
};
var CancelToken_default = CancelToken$1;

//#endregion
//#region node_modules/axios/lib/helpers/spread.js
/**
* Syntactic sugar for invoking a function and expanding an array for arguments.
*
* Common use case would be to use `Function.prototype.apply`.
*
*  ```js
*  function f(x, y, z) {}
*  const args = [1, 2, 3];
*  f.apply(null, args);
*  ```
*
* With `spread` this example can be re-written.
*
*  ```js
*  spread(function(x, y, z) {})([1, 2, 3]);
*  ```
*
* @param {Function} callback
*
* @returns {Function}
*/
function spread$1(callback) {
	return function wrap(arr) {
		return callback.apply(null, arr);
	};
}

//#endregion
//#region node_modules/axios/lib/helpers/isAxiosError.js
/**
* Determines whether the payload is an error thrown by Axios
*
* @param {*} payload The value to test
*
* @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
*/
function isAxiosError$1(payload) {
	return utils_default.isObject(payload) && payload.isAxiosError === true;
}

//#endregion
//#region node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode$1 = {
	Continue: 100,
	SwitchingProtocols: 101,
	Processing: 102,
	EarlyHints: 103,
	Ok: 200,
	Created: 201,
	Accepted: 202,
	NonAuthoritativeInformation: 203,
	NoContent: 204,
	ResetContent: 205,
	PartialContent: 206,
	MultiStatus: 207,
	AlreadyReported: 208,
	ImUsed: 226,
	MultipleChoices: 300,
	MovedPermanently: 301,
	Found: 302,
	SeeOther: 303,
	NotModified: 304,
	UseProxy: 305,
	Unused: 306,
	TemporaryRedirect: 307,
	PermanentRedirect: 308,
	BadRequest: 400,
	Unauthorized: 401,
	PaymentRequired: 402,
	Forbidden: 403,
	NotFound: 404,
	MethodNotAllowed: 405,
	NotAcceptable: 406,
	ProxyAuthenticationRequired: 407,
	RequestTimeout: 408,
	Conflict: 409,
	Gone: 410,
	LengthRequired: 411,
	PreconditionFailed: 412,
	PayloadTooLarge: 413,
	UriTooLong: 414,
	UnsupportedMediaType: 415,
	RangeNotSatisfiable: 416,
	ExpectationFailed: 417,
	ImATeapot: 418,
	MisdirectedRequest: 421,
	UnprocessableEntity: 422,
	Locked: 423,
	FailedDependency: 424,
	TooEarly: 425,
	UpgradeRequired: 426,
	PreconditionRequired: 428,
	TooManyRequests: 429,
	RequestHeaderFieldsTooLarge: 431,
	UnavailableForLegalReasons: 451,
	InternalServerError: 500,
	NotImplemented: 501,
	BadGateway: 502,
	ServiceUnavailable: 503,
	GatewayTimeout: 504,
	HttpVersionNotSupported: 505,
	VariantAlsoNegotiates: 506,
	InsufficientStorage: 507,
	LoopDetected: 508,
	NotExtended: 510,
	NetworkAuthenticationRequired: 511,
	WebServerIsDown: 521,
	ConnectionTimedOut: 522,
	OriginIsUnreachable: 523,
	TimeoutOccurred: 524,
	SslHandshakeFailed: 525,
	InvalidSslCertificate: 526
};
Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
	HttpStatusCode$1[value] = key;
});
var HttpStatusCode_default = HttpStatusCode$1;

//#endregion
//#region node_modules/axios/lib/axios.js
/**
* Create an instance of Axios
*
* @param {Object} defaultConfig The default config for the instance
*
* @returns {Axios} A new instance of Axios
*/
function createInstance(defaultConfig) {
	const context = new Axios_default(defaultConfig);
	const instance = bind$4(Axios_default.prototype.request, context);
	utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
	utils_default.extend(instance, context, null, { allOwnKeys: true });
	instance.create = function create$2(instanceConfig) {
		return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
	};
	return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all$1(promises) {
	return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

//#endregion
//#region node_modules/axios/index.js
var { Axios, AxiosError, CanceledError, isCancel, CancelToken, VERSION, all, Cancel, isAxiosError, spread, toFormData, AxiosHeaders, HttpStatusCode, formToJSON, getAdapter, mergeConfig } = axios_default;

//#endregion
//#region node_modules/fast-copy/dist/esm/index.mjs
var toStringFunction = Function.prototype.toString;
var create$1 = Object.create;
var toStringObject = Object.prototype.toString;
/**
* @classdesc Fallback cache for when WeakMap is not natively supported
*/
var LegacyCache = function() {
	function LegacyCache$1() {
		this._keys = [];
		this._values = [];
	}
	LegacyCache$1.prototype.has = function(key) {
		return !!~this._keys.indexOf(key);
	};
	LegacyCache$1.prototype.get = function(key) {
		return this._values[this._keys.indexOf(key)];
	};
	LegacyCache$1.prototype.set = function(key, value) {
		this._keys.push(key);
		this._values.push(value);
	};
	return LegacyCache$1;
}();
function createCacheLegacy() {
	return new LegacyCache();
}
function createCacheModern() {
	return /* @__PURE__ */ new WeakMap();
}
/**
* Get a new cache object to prevent circular references.
*/
var createCache = typeof WeakMap !== "undefined" ? createCacheModern : createCacheLegacy;
/**
* Get an empty version of the object with the same prototype it has.
*/
function getCleanClone(prototype$1) {
	if (!prototype$1) return create$1(null);
	var Constructor = prototype$1.constructor;
	if (Constructor === Object) return prototype$1 === Object.prototype ? {} : create$1(prototype$1);
	if (Constructor && ~toStringFunction.call(Constructor).indexOf("[native code]")) try {
		return new Constructor();
	} catch (_a$1) {}
	return create$1(prototype$1);
}
function getRegExpFlagsLegacy(regExp) {
	var flags = "";
	if (regExp.global) flags += "g";
	if (regExp.ignoreCase) flags += "i";
	if (regExp.multiline) flags += "m";
	if (regExp.unicode) flags += "u";
	if (regExp.sticky) flags += "y";
	return flags;
}
function getRegExpFlagsModern(regExp) {
	return regExp.flags;
}
/**
* Get the flags to apply to the copied regexp.
*/
var getRegExpFlags = /test/g.flags === "g" ? getRegExpFlagsModern : getRegExpFlagsLegacy;
function getTagLegacy(value) {
	var type = toStringObject.call(value);
	return type.substring(8, type.length - 1);
}
function getTagModern(value) {
	return value[Symbol.toStringTag] || getTagLegacy(value);
}
/**
* Get the tag of the value passed, so that the correct copier can be used.
*/
var getTag = typeof Symbol !== "undefined" ? getTagModern : getTagLegacy;
var defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;
var _a = Object.prototype, hasOwnProperty$2 = _a.hasOwnProperty, propertyIsEnumerable = _a.propertyIsEnumerable;
var SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === "function";
function getStrictPropertiesModern(object) {
	return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
/**
* Get the properites used when copying objects strictly. This includes both keys and symbols.
*/
var getStrictProperties = SUPPORTS_SYMBOL ? getStrictPropertiesModern : getOwnPropertyNames;
/**
* Striclty copy all properties contained on the object.
*/
function copyOwnPropertiesStrict(value, clone, state) {
	var properties = getStrictProperties(value);
	for (var index$1 = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index$1 < length_1; ++index$1) {
		property = properties[index$1];
		if (property === "callee" || property === "caller") continue;
		descriptor = getOwnPropertyDescriptor(value, property);
		if (!descriptor) {
			clone[property] = state.copier(value[property], state);
			continue;
		}
		if (!descriptor.get && !descriptor.set) descriptor.value = state.copier(descriptor.value, state);
		try {
			defineProperty(clone, property, descriptor);
		} catch (error) {
			clone[property] = descriptor.value;
		}
	}
	return clone;
}
/**
* Deeply copy the indexed values in the array.
*/
function copyArrayLoose(array, state) {
	var clone = new state.Constructor();
	state.cache.set(array, clone);
	for (var index$1 = 0, length_2 = array.length; index$1 < length_2; ++index$1) clone[index$1] = state.copier(array[index$1], state);
	return clone;
}
/**
* Deeply copy the indexed values in the array, as well as any custom properties.
*/
function copyArrayStrict(array, state) {
	var clone = new state.Constructor();
	state.cache.set(array, clone);
	return copyOwnPropertiesStrict(array, clone, state);
}
/**
* Copy the contents of the ArrayBuffer.
*/
function copyArrayBuffer(arrayBuffer, _state) {
	return arrayBuffer.slice(0);
}
/**
* Create a new Blob with the contents of the original.
*/
function copyBlob(blob, _state) {
	return blob.slice(0, blob.size, blob.type);
}
/**
* Create a new DataView with the contents of the original.
*/
function copyDataView(dataView, state) {
	return new state.Constructor(copyArrayBuffer(dataView.buffer));
}
/**
* Create a new Date based on the time of the original.
*/
function copyDate(date, state) {
	return new state.Constructor(date.getTime());
}
/**
* Deeply copy the keys and values of the original.
*/
function copyMapLoose(map, state) {
	var clone = new state.Constructor();
	state.cache.set(map, clone);
	map.forEach(function(value, key) {
		clone.set(key, state.copier(value, state));
	});
	return clone;
}
/**
* Deeply copy the keys and values of the original, as well as any custom properties.
*/
function copyMapStrict(map, state) {
	return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);
}
function copyObjectLooseLegacy(object, state) {
	var clone = getCleanClone(state.prototype);
	state.cache.set(object, clone);
	for (var key in object) if (hasOwnProperty$2.call(object, key)) clone[key] = state.copier(object[key], state);
	return clone;
}
function copyObjectLooseModern(object, state) {
	var clone = getCleanClone(state.prototype);
	state.cache.set(object, clone);
	for (var key in object) if (hasOwnProperty$2.call(object, key)) clone[key] = state.copier(object[key], state);
	var symbols = getOwnPropertySymbols(object);
	for (var index$1 = 0, length_3 = symbols.length, symbol = void 0; index$1 < length_3; ++index$1) {
		symbol = symbols[index$1];
		if (propertyIsEnumerable.call(object, symbol)) clone[symbol] = state.copier(object[symbol], state);
	}
	return clone;
}
/**
* Deeply copy the properties (keys and symbols) and values of the original.
*/
var copyObjectLoose = SUPPORTS_SYMBOL ? copyObjectLooseModern : copyObjectLooseLegacy;
/**
* Deeply copy the properties (keys and symbols) and values of the original, as well
* as any hidden or non-enumerable properties.
*/
function copyObjectStrict(object, state) {
	var clone = getCleanClone(state.prototype);
	state.cache.set(object, clone);
	return copyOwnPropertiesStrict(object, clone, state);
}
/**
* Create a new primitive wrapper from the value of the original.
*/
function copyPrimitiveWrapper(primitiveObject, state) {
	return new state.Constructor(primitiveObject.valueOf());
}
/**
* Create a new RegExp based on the value and flags of the original.
*/
function copyRegExp(regExp, state) {
	var clone = new state.Constructor(regExp.source, getRegExpFlags(regExp));
	clone.lastIndex = regExp.lastIndex;
	return clone;
}
/**
* Return the original value (an identity function).
*
* @note
* THis is used for objects that cannot be copied, such as WeakMap.
*/
function copySelf(value, _state) {
	return value;
}
/**
* Deeply copy the values of the original.
*/
function copySetLoose(set, state) {
	var clone = new state.Constructor();
	state.cache.set(set, clone);
	set.forEach(function(value) {
		clone.add(state.copier(value, state));
	});
	return clone;
}
/**
* Deeply copy the values of the original, as well as any custom properties.
*/
function copySetStrict(set, state) {
	return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);
}
var isArray$6 = Array.isArray;
var assign$1 = Object.assign;
var getPrototypeOf = Object.getPrototypeOf || (function(obj) {
	return obj.__proto__;
});
var DEFAULT_LOOSE_OPTIONS = {
	array: copyArrayLoose,
	arrayBuffer: copyArrayBuffer,
	blob: copyBlob,
	dataView: copyDataView,
	date: copyDate,
	error: copySelf,
	map: copyMapLoose,
	object: copyObjectLoose,
	regExp: copyRegExp,
	set: copySetLoose
};
var DEFAULT_STRICT_OPTIONS = assign$1({}, DEFAULT_LOOSE_OPTIONS, {
	array: copyArrayStrict,
	map: copyMapStrict,
	object: copyObjectStrict,
	set: copySetStrict
});
/**
* Get the copiers used for each specific object tag.
*/
function getTagSpecificCopiers(options) {
	return {
		Arguments: options.object,
		Array: options.array,
		ArrayBuffer: options.arrayBuffer,
		Blob: options.blob,
		Boolean: copyPrimitiveWrapper,
		DataView: options.dataView,
		Date: options.date,
		Error: options.error,
		Float32Array: options.arrayBuffer,
		Float64Array: options.arrayBuffer,
		Int8Array: options.arrayBuffer,
		Int16Array: options.arrayBuffer,
		Int32Array: options.arrayBuffer,
		Map: options.map,
		Number: copyPrimitiveWrapper,
		Object: options.object,
		Promise: copySelf,
		RegExp: options.regExp,
		Set: options.set,
		String: copyPrimitiveWrapper,
		WeakMap: copySelf,
		WeakSet: copySelf,
		Uint8Array: options.arrayBuffer,
		Uint8ClampedArray: options.arrayBuffer,
		Uint16Array: options.arrayBuffer,
		Uint32Array: options.arrayBuffer,
		Uint64Array: options.arrayBuffer
	};
}
/**
* Create a custom copier based on the object-specific copy methods passed.
*/
function createCopier(options) {
	var tagSpecificCopiers = getTagSpecificCopiers(assign$1({}, DEFAULT_LOOSE_OPTIONS, options));
	var array = tagSpecificCopiers.Array, object = tagSpecificCopiers.Object;
	function copier(value, state) {
		state.prototype = state.Constructor = void 0;
		if (!value || typeof value !== "object") return value;
		if (state.cache.has(value)) return state.cache.get(value);
		state.prototype = getPrototypeOf(value);
		state.Constructor = state.prototype && state.prototype.constructor;
		if (!state.Constructor || state.Constructor === Object) return object(value, state);
		if (isArray$6(value)) return array(value, state);
		var tagSpecificCopier = tagSpecificCopiers[getTag(value)];
		if (tagSpecificCopier) return tagSpecificCopier(value, state);
		return typeof value.then === "function" ? value : object(value, state);
	}
	return function copy(value) {
		return copier(value, {
			Constructor: void 0,
			cache: createCache(),
			copier,
			prototype: void 0
		});
	};
}
/**
* Create a custom copier based on the object-specific copy methods passed, defaulting to the
* same internals as `copyStrict`.
*/
function createStrictCopier(options) {
	return createCopier(assign$1({}, DEFAULT_STRICT_OPTIONS, options));
}
/**
* Copy an value deeply as much as possible, where strict recreation of object properties
* are maintained. All properties (including non-enumerable ones) are copied with their
* original property descriptors on both objects and arrays.
*/
var copyStrict = createStrictCopier({});
/**
* Copy an value deeply as much as possible.
*/
var index = createCopier({});

//#endregion
//#region node_modules/contentful-sdk-core/dist/async-token.js
function asyncToken(instance, getToken$1) {
	instance.interceptors.request.use(function(config) {
		return getToken$1().then((accessToken) => {
			config.headers.set("Authorization", `Bearer ${accessToken}`);
			return config;
		});
	});
}

//#endregion
//#region node_modules/process/browser.js
var require_browser = /* @__PURE__ */ __commonJS({ "node_modules/process/browser.js": ((exports, module) => {
	var process$3 = module.exports = {};
	var cachedSetTimeout;
	var cachedClearTimeout;
	function defaultSetTimout() {
		throw new Error("setTimeout has not been defined");
	}
	function defaultClearTimeout() {
		throw new Error("clearTimeout has not been defined");
	}
	(function() {
		try {
			if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
			else cachedSetTimeout = defaultSetTimout;
		} catch (e) {
			cachedSetTimeout = defaultSetTimout;
		}
		try {
			if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
			else cachedClearTimeout = defaultClearTimeout;
		} catch (e) {
			cachedClearTimeout = defaultClearTimeout;
		}
	})();
	function runTimeout(fun) {
		if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
		if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
			cachedSetTimeout = setTimeout;
			return setTimeout(fun, 0);
		}
		try {
			return cachedSetTimeout(fun, 0);
		} catch (e) {
			try {
				return cachedSetTimeout.call(null, fun, 0);
			} catch (e$1) {
				return cachedSetTimeout.call(this, fun, 0);
			}
		}
	}
	function runClearTimeout(marker) {
		if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
		if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
			cachedClearTimeout = clearTimeout;
			return clearTimeout(marker);
		}
		try {
			return cachedClearTimeout(marker);
		} catch (e) {
			try {
				return cachedClearTimeout.call(null, marker);
			} catch (e$1) {
				return cachedClearTimeout.call(this, marker);
			}
		}
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	function cleanUpNextTick() {
		if (!draining || !currentQueue) return;
		draining = false;
		if (currentQueue.length) queue = currentQueue.concat(queue);
		else queueIndex = -1;
		if (queue.length) drainQueue();
	}
	function drainQueue() {
		if (draining) return;
		var timeout = runTimeout(cleanUpNextTick);
		draining = true;
		var len = queue.length;
		while (len) {
			currentQueue = queue;
			queue = [];
			while (++queueIndex < len) if (currentQueue) currentQueue[queueIndex].run();
			queueIndex = -1;
			len = queue.length;
		}
		currentQueue = null;
		draining = false;
		runClearTimeout(timeout);
	}
	process$3.nextTick = function(fun) {
		var args = new Array(arguments.length - 1);
		if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
		queue.push(new Item(fun, args));
		if (queue.length === 1 && !draining) runTimeout(drainQueue);
	};
	function Item(fun, array) {
		this.fun = fun;
		this.array = array;
	}
	Item.prototype.run = function() {
		this.fun.apply(null, this.array);
	};
	process$3.title = "browser";
	process$3.browser = true;
	process$3.env = {};
	process$3.argv = [];
	process$3.version = "";
	process$3.versions = {};
	function noop$1() {}
	process$3.on = noop$1;
	process$3.addListener = noop$1;
	process$3.once = noop$1;
	process$3.off = noop$1;
	process$3.removeListener = noop$1;
	process$3.removeAllListeners = noop$1;
	process$3.emit = noop$1;
	process$3.prependListener = noop$1;
	process$3.prependOnceListener = noop$1;
	process$3.listeners = function(name) {
		return [];
	};
	process$3.binding = function(name) {
		throw new Error("process.binding is not supported");
	};
	process$3.cwd = function() {
		return "/";
	};
	process$3.chdir = function(dir) {
		throw new Error("process.chdir is not supported");
	};
	process$3.umask = function() {
		return 0;
	};
}) });

//#endregion
//#region node_modules/contentful-sdk-core/dist/utils.js
var import_browser$1 = /* @__PURE__ */ __toESM(require_browser(), 1);
function isNode() {
	/**
	* Polyfills of 'process' might set process.browser === true
	*
	* See:
	* https://github.com/webpack/node-libs-browser/blob/master/mock/process.js#L8
	* https://github.com/defunctzombie/node-process/blob/master/browser.js#L156
	**/
	return typeof import_browser$1.default !== "undefined" && !import_browser$1.default.browser;
}
function isReactNative() {
	return typeof window !== "undefined" && "navigator" in window && "product" in window.navigator && window.navigator.product === "ReactNative";
}
function getNodeVersion() {
	return import_browser$1.default.versions && import_browser$1.default.versions.node ? `v${import_browser$1.default.versions.node}` : import_browser$1.default.version;
}
function getWindow() {
	return window;
}
function noop() {}

//#endregion
//#region node_modules/contentful-sdk-core/dist/rate-limit.js
var delay = (ms) => new Promise((resolve) => {
	setTimeout(resolve, ms);
});
var defaultWait = (attempts) => {
	return Math.pow(Math.SQRT2, attempts);
};
function rateLimit(instance, maxRetry = 5) {
	const { responseLogger = noop, requestLogger = noop } = instance.defaults;
	instance.interceptors.request.use(function(config) {
		requestLogger(config);
		return config;
	}, function(error) {
		requestLogger(error);
		return Promise.reject(error);
	});
	instance.interceptors.response.use(function(response) {
		responseLogger(response);
		return response;
	}, async function(error) {
		const { response } = error;
		const { config } = error;
		responseLogger(error);
		if (!config || !instance.defaults.retryOnError) return Promise.reject(error);
		const doneAttempts = config.attempts || 1;
		if (doneAttempts > maxRetry) {
			error.attempts = config.attempts;
			return Promise.reject(error);
		}
		let retryErrorType = null;
		let wait = defaultWait(doneAttempts);
		if (!response) retryErrorType = "Connection";
		else if (response.status >= 500 && response.status < 600) retryErrorType = `Server ${response.status}`;
		else if (response.status === 429) {
			retryErrorType = "Rate limit";
			if (response.headers && error.response.headers["x-contentful-ratelimit-reset"]) wait = response.headers["x-contentful-ratelimit-reset"];
		}
		if (retryErrorType) {
			wait = Math.floor(wait * 1e3 + Math.random() * 200 + 500);
			instance.defaults.logHandler("warning", `${retryErrorType} error occurred. Waiting for ${wait} ms before retrying...`);
			config.attempts = doneAttempts + 1;
			delete config.httpAgent;
			delete config.httpsAgent;
			return delay(wait).then(() => instance(config));
		}
		return Promise.reject(error);
	});
}

//#endregion
//#region node_modules/lodash/_freeGlobal.js
var require__freeGlobal = /* @__PURE__ */ __commonJS({ "node_modules/lodash/_freeGlobal.js": ((exports, module) => {
	/** Detect free variable `global` from Node.js. */
	var freeGlobal$1 = typeof global == "object" && global && global.Object === Object && global;
	module.exports = freeGlobal$1;
}) });

//#endregion
//#region node_modules/lodash/_root.js
var require__root = /* @__PURE__ */ __commonJS({ "node_modules/lodash/_root.js": ((exports, module) => {
	var freeGlobal = require__freeGlobal();
	/** Detect free variable `self`. */
	var freeSelf = typeof self == "object" && self && self.Object === Object && self;
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function("return this")();
	module.exports = root;
}) });

//#endregion
//#region node_modules/lodash/_Symbol.js
var require__Symbol = /* @__PURE__ */ __commonJS({ "node_modules/lodash/_Symbol.js": ((exports, module) => {
	/** Built-in value references. */
	var Symbol$3 = require__root().Symbol;
	module.exports = Symbol$3;
}) });

//#endregion
//#region node_modules/lodash/_getRawTag.js
var require__getRawTag = /* @__PURE__ */ __commonJS({ "node_modules/lodash/_getRawTag.js": ((exports, module) => {
	var Symbol$2 = require__Symbol();
	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;
	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
	/**
	* Used to resolve the
	* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	* of values.
	*/
	var nativeObjectToString$1 = objectProto$1.toString;
	/** Built-in value references. */
	var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
	/**
	* A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	*
	* @private
	* @param {*} value The value to query.
	* @returns {string} Returns the raw `toStringTag`.
	*/
	function getRawTag$1(value) {
		var isOwn = hasOwnProperty$1.call(value, symToStringTag$1), tag = value[symToStringTag$1];
		try {
			value[symToStringTag$1] = void 0;
			var unmasked = true;
		} catch (e) {}
		var result = nativeObjectToString$1.call(value);
		if (unmasked) if (isOwn) value[symToStringTag$1] = tag;
		else delete value[symToStringTag$1];
		return result;
	}
	module.exports = getRawTag$1;
}) });

//#endregion
//#region node_modules/lodash/_objectToString.js
var require__objectToString = /* @__PURE__ */ __commonJS({ "node_modules/lodash/_objectToString.js": ((exports, module) => {
	/**
	* Used to resolve the
	* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	* of values.
	*/
	var nativeObjectToString = Object.prototype.toString;
	/**
	* Converts `value` to a string using `Object.prototype.toString`.
	*
	* @private
	* @param {*} value The value to convert.
	* @returns {string} Returns the converted string.
	*/
	function objectToString$2(value) {
		return nativeObjectToString.call(value);
	}
	module.exports = objectToString$2;
}) });

//#endregion
//#region node_modules/lodash/_baseGetTag.js
var require__baseGetTag = /* @__PURE__ */ __commonJS({ "node_modules/lodash/_baseGetTag.js": ((exports, module) => {
	var Symbol$1 = require__Symbol(), getRawTag = require__getRawTag(), objectToString$1 = require__objectToString();
	/** `Object#toString` result references. */
	var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
	/** Built-in value references. */
	var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
	/**
	* The base implementation of `getTag` without fallbacks for buggy environments.
	*
	* @private
	* @param {*} value The value to query.
	* @returns {string} Returns the `toStringTag`.
	*/
	function baseGetTag$2(value) {
		if (value == null) return value === void 0 ? undefinedTag : nullTag;
		return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
	}
	module.exports = baseGetTag$2;
}) });

//#endregion
//#region node_modules/lodash/isArray.js
var require_isArray = /* @__PURE__ */ __commonJS({ "node_modules/lodash/isArray.js": ((exports, module) => {
	/**
	* Checks if `value` is classified as an `Array` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an array, else `false`.
	* @example
	*
	* _.isArray([1, 2, 3]);
	* // => true
	*
	* _.isArray(document.body.children);
	* // => false
	*
	* _.isArray('abc');
	* // => false
	*
	* _.isArray(_.noop);
	* // => false
	*/
	var isArray$5 = Array.isArray;
	module.exports = isArray$5;
}) });

//#endregion
//#region node_modules/lodash/isObjectLike.js
var require_isObjectLike = /* @__PURE__ */ __commonJS({ "node_modules/lodash/isObjectLike.js": ((exports, module) => {
	/**
	* Checks if `value` is object-like. A value is object-like if it's not `null`
	* and has a `typeof` result of "object".
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	* @example
	*
	* _.isObjectLike({});
	* // => true
	*
	* _.isObjectLike([1, 2, 3]);
	* // => true
	*
	* _.isObjectLike(_.noop);
	* // => false
	*
	* _.isObjectLike(null);
	* // => false
	*/
	function isObjectLike$2(value) {
		return value != null && typeof value == "object";
	}
	module.exports = isObjectLike$2;
}) });

//#endregion
//#region node_modules/lodash/isString.js
var require_isString = /* @__PURE__ */ __commonJS({ "node_modules/lodash/isString.js": ((exports, module) => {
	var baseGetTag$1 = require__baseGetTag(), isArray$4 = require_isArray(), isObjectLike$1 = require_isObjectLike();
	/** `Object#toString` result references. */
	var stringTag = "[object String]";
	/**
	* Checks if `value` is classified as a `String` primitive or object.
	*
	* @static
	* @since 0.1.0
	* @memberOf _
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a string, else `false`.
	* @example
	*
	* _.isString('abc');
	* // => true
	*
	* _.isString(1);
	* // => false
	*/
	function isString$2(value) {
		return typeof value == "string" || !isArray$4(value) && isObjectLike$1(value) && baseGetTag$1(value) == stringTag;
	}
	module.exports = isString$2;
}) });

//#endregion
//#region node_modules/contentful-sdk-core/dist/pThrottle.js
var import_isString = /* @__PURE__ */ __toESM(require_isString(), 1);
var AbortError = class extends Error {
	name = "AbortError";
	constructor() {
		super("Throttled function aborted");
	}
};
/**
* Throttle promise-returning/async/normal functions.
*
* It rate-limits function calls without discarding them, making it ideal for external API interactions where avoiding call loss is crucial.
*
* @returns A throttle function.
*
* Both the `limit` and `interval` options must be specified.
*
* @example
* ```
* import pThrottle from './PThrottle';
*
* const now = Date.now();
*
* const throttle = pThrottle({
*   limit: 2,
*   interval: 1000
* });
*
* const throttled = throttle(async index => {
*   const secDiff = ((Date.now() - now) / 1000).toFixed();
*   return `${index}: ${secDiff}s`;
* });
*
* for (let index = 1; index <= 6; index++) {
*   (async () => {
*     console.log(await throttled(index));
*   })();
* }
* //=> 1: 0s
* //=> 2: 0s
* //=> 3: 1s
* //=> 4: 1s
* //=> 5: 2s
* //=> 6: 2s
* ```
*/
function pThrottle({ limit: limit$1, interval, strict, onDelay }) {
	if (!Number.isFinite(limit$1)) throw new TypeError("Expected `limit` to be a finite number");
	if (!Number.isFinite(interval)) throw new TypeError("Expected `interval` to be a finite number");
	const queue$1 = /* @__PURE__ */ new Map();
	let currentTick = 0;
	let activeCount = 0;
	function windowedDelay() {
		const now = Date.now();
		if (now - currentTick > interval) {
			activeCount = 1;
			currentTick = now;
			return 0;
		}
		if (activeCount < limit$1) activeCount++;
		else {
			currentTick += interval;
			activeCount = 1;
		}
		return currentTick - now;
	}
	const getDelay = windowedDelay;
	return function(function_) {
		const throttled = function(...arguments_) {
			if (!throttled.isEnabled) return (async () => function_.apply(this, arguments_))();
			let timeoutId;
			return new Promise((resolve, reject) => {
				const execute = () => {
					resolve(function_.apply(this, arguments_));
					queue$1.delete(timeoutId);
				};
				const delay$1 = getDelay();
				if (delay$1 > 0) {
					timeoutId = setTimeout(execute, delay$1);
					queue$1.set(timeoutId, reject);
					onDelay?.();
				} else execute();
			});
		};
		throttled.abort = () => {
			for (const timeout of queue$1.keys()) {
				clearTimeout(timeout);
				queue$1.get(timeout)(new AbortError());
			}
			queue$1.clear();
		};
		throttled.isEnabled = true;
		Object.defineProperty(throttled, "queueSize", { get() {
			return queue$1.size;
		} });
		return throttled;
	};
}

//#endregion
//#region node_modules/contentful-sdk-core/dist/rate-limit-throttle.js
var PERCENTAGE_REGEX = /(?<value>\d+)(%)/;
function calculateLimit(type, max$2 = 7) {
	let limit$1 = max$2;
	if (PERCENTAGE_REGEX.test(type)) {
		const groups = type.match(PERCENTAGE_REGEX)?.groups;
		if (groups && groups.value) {
			const percentage = parseInt(groups.value) / 100;
			limit$1 = Math.round(max$2 * percentage);
		}
	}
	return Math.min(30, Math.max(1, limit$1));
}
function createThrottle(limit$1, logger) {
	logger("info", `Throttle request to ${limit$1}/s`);
	return pThrottle({
		limit: limit$1,
		interval: 1e3,
		strict: false
	});
}
var rateLimitThrottle = (axiosInstance, type = "auto") => {
	const { logHandler = noop } = axiosInstance.defaults;
	let limit$1 = (0, import_isString.default)(type) ? calculateLimit(type) : calculateLimit("auto", type);
	let throttle$1 = createThrottle(limit$1, logHandler);
	let isCalculated = false;
	let requestInterceptorId = axiosInstance.interceptors.request.use((config) => {
		return throttle$1(() => config)();
	}, function(error) {
		return Promise.reject(error);
	});
	const responseInterceptorId = axiosInstance.interceptors.response.use((response) => {
		if (!isCalculated && (0, import_isString.default)(type) && (type === "auto" || PERCENTAGE_REGEX.test(type)) && response.headers && response.headers["x-contentful-ratelimit-second-limit"]) {
			const nextLimit = calculateLimit(type, parseInt(response.headers["x-contentful-ratelimit-second-limit"]));
			if (nextLimit !== limit$1) {
				if (requestInterceptorId) axiosInstance.interceptors.request.eject(requestInterceptorId);
				limit$1 = nextLimit;
				throttle$1 = createThrottle(nextLimit, logHandler);
				requestInterceptorId = axiosInstance.interceptors.request.use((config) => {
					return throttle$1(() => config)();
				}, function(error) {
					return Promise.reject(error);
				});
			}
			isCalculated = true;
		}
		return response;
	}, function(error) {
		return Promise.reject(error);
	});
	return () => {
		axiosInstance.interceptors.request.eject(requestInterceptorId);
		axiosInstance.interceptors.response.eject(responseInterceptorId);
	};
};

//#endregion
//#region node_modules/es-errors/type.js
var require_type = /* @__PURE__ */ __commonJS({ "node_modules/es-errors/type.js": ((exports, module) => {
	/** @type {import('./type')} */
	module.exports = TypeError;
}) });

//#endregion
//#region (ignored) node_modules/object-inspect/util.inspect.js
var require_util_inspect = /* @__PURE__ */ __commonJS({ "node_modules/object-inspect/util.inspect.js": (() => {}) });

//#endregion
//#region node_modules/object-inspect/index.js
var require_object_inspect = /* @__PURE__ */ __commonJS({ "node_modules/object-inspect/index.js": ((exports, module) => {
	var hasMap = typeof Map === "function" && Map.prototype;
	var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
	var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
	var mapForEach = hasMap && Map.prototype.forEach;
	var hasSet = typeof Set === "function" && Set.prototype;
	var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
	var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
	var setForEach = hasSet && Set.prototype.forEach;
	var weakMapHas = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap.prototype.has : null;
	var weakSetHas = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet.prototype.has : null;
	var weakRefDeref = typeof WeakRef === "function" && WeakRef.prototype ? WeakRef.prototype.deref : null;
	var booleanValueOf = Boolean.prototype.valueOf;
	var objectToString = Object.prototype.toString;
	var functionToString = Function.prototype.toString;
	var $match = String.prototype.match;
	var $slice = String.prototype.slice;
	var $replace$1 = String.prototype.replace;
	var $toUpperCase = String.prototype.toUpperCase;
	var $toLowerCase = String.prototype.toLowerCase;
	var $test = RegExp.prototype.test;
	var $concat$1 = Array.prototype.concat;
	var $join = Array.prototype.join;
	var $arrSlice = Array.prototype.slice;
	var $floor = Math.floor;
	var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
	var gOPS = Object.getOwnPropertySymbols;
	var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
	var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
	var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O$1) {
		return O$1.__proto__;
	} : null);
	function addNumericSeparator(num, str) {
		if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) return str;
		var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
		if (typeof num === "number") {
			var int = num < 0 ? -$floor(-num) : $floor(num);
			if (int !== num) {
				var intStr = String(int);
				var dec = $slice.call(str, intStr.length + 1);
				return $replace$1.call(intStr, sepRegex, "$&_") + "." + $replace$1.call($replace$1.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
			}
		}
		return $replace$1.call(str, sepRegex, "$&_");
	}
	var utilInspect = require_util_inspect();
	var inspectCustom = utilInspect.custom;
	var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
	var quotes = {
		__proto__: null,
		"double": "\"",
		single: "'"
	};
	var quoteREs = {
		__proto__: null,
		"double": /(["\\])/g,
		single: /(['\\])/g
	};
	module.exports = function inspect_(obj, options, depth, seen) {
		var opts = options || {};
		if (has$3(opts, "quoteStyle") && !has$3(quotes, opts.quoteStyle)) throw new TypeError("option \"quoteStyle\" must be \"single\" or \"double\"");
		if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) throw new TypeError("option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`");
		var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
		if (typeof customInspect !== "boolean" && customInspect !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
		if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) throw new TypeError("option \"indent\" must be \"\\t\", an integer > 0, or `null`");
		if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") throw new TypeError("option \"numericSeparator\", if provided, must be `true` or `false`");
		var numericSeparator = opts.numericSeparator;
		if (typeof obj === "undefined") return "undefined";
		if (obj === null) return "null";
		if (typeof obj === "boolean") return obj ? "true" : "false";
		if (typeof obj === "string") return inspectString(obj, opts);
		if (typeof obj === "number") {
			if (obj === 0) return Infinity / obj > 0 ? "0" : "-0";
			var str = String(obj);
			return numericSeparator ? addNumericSeparator(obj, str) : str;
		}
		if (typeof obj === "bigint") {
			var bigIntStr = String(obj) + "n";
			return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
		}
		var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
		if (typeof depth === "undefined") depth = 0;
		if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") return isArray$3(obj) ? "[Array]" : "[Object]";
		var indent = getIndent(opts, depth);
		if (typeof seen === "undefined") seen = [];
		else if (indexOf(seen, obj) >= 0) return "[Circular]";
		function inspect$4(value, from, noIndent) {
			if (from) {
				seen = $arrSlice.call(seen);
				seen.push(from);
			}
			if (noIndent) {
				var newOpts = { depth: opts.depth };
				if (has$3(opts, "quoteStyle")) newOpts.quoteStyle = opts.quoteStyle;
				return inspect_(value, newOpts, depth + 1, seen);
			}
			return inspect_(value, opts, depth + 1, seen);
		}
		if (typeof obj === "function" && !isRegExp$1(obj)) {
			var name = nameOf(obj);
			var keys = arrObjKeys(obj, inspect$4);
			return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
		}
		if (isSymbol(obj)) {
			var symString = hasShammedSymbols ? $replace$1.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
			return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
		}
		if (isElement(obj)) {
			var s = "<" + $toLowerCase.call(String(obj.nodeName));
			var attrs = obj.attributes || [];
			for (var i = 0; i < attrs.length; i++) s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
			s += ">";
			if (obj.childNodes && obj.childNodes.length) s += "...";
			s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
			return s;
		}
		if (isArray$3(obj)) {
			if (obj.length === 0) return "[]";
			var xs = arrObjKeys(obj, inspect$4);
			if (indent && !singleLineValues(xs)) return "[" + indentedJoin(xs, indent) + "]";
			return "[ " + $join.call(xs, ", ") + " ]";
		}
		if (isError(obj)) {
			var parts = arrObjKeys(obj, inspect$4);
			if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) return "{ [" + String(obj) + "] " + $join.call($concat$1.call("[cause]: " + inspect$4(obj.cause), parts), ", ") + " }";
			if (parts.length === 0) return "[" + String(obj) + "]";
			return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
		}
		if (typeof obj === "object" && customInspect) {
			if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) return utilInspect(obj, { depth: maxDepth - depth });
			else if (customInspect !== "symbol" && typeof obj.inspect === "function") return obj.inspect();
		}
		if (isMap(obj)) {
			var mapParts = [];
			if (mapForEach) mapForEach.call(obj, function(value, key) {
				mapParts.push(inspect$4(key, obj, true) + " => " + inspect$4(value, obj));
			});
			return collectionOf("Map", mapSize.call(obj), mapParts, indent);
		}
		if (isSet(obj)) {
			var setParts = [];
			if (setForEach) setForEach.call(obj, function(value) {
				setParts.push(inspect$4(value, obj));
			});
			return collectionOf("Set", setSize.call(obj), setParts, indent);
		}
		if (isWeakMap(obj)) return weakCollectionOf("WeakMap");
		if (isWeakSet(obj)) return weakCollectionOf("WeakSet");
		if (isWeakRef(obj)) return weakCollectionOf("WeakRef");
		if (isNumber(obj)) return markBoxed(inspect$4(Number(obj)));
		if (isBigInt(obj)) return markBoxed(inspect$4(bigIntValueOf.call(obj)));
		if (isBoolean(obj)) return markBoxed(booleanValueOf.call(obj));
		if (isString(obj)) return markBoxed(inspect$4(String(obj)));
		if (typeof window !== "undefined" && obj === window) return "{ [object Window] }";
		if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) return "{ [object globalThis] }";
		if (!isDate(obj) && !isRegExp$1(obj)) {
			var ys = arrObjKeys(obj, inspect$4);
			var isPlainObject$3 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
			var protoTag = obj instanceof Object ? "" : "null prototype";
			var stringTag$1 = !isPlainObject$3 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr$1(obj), 8, -1) : protoTag ? "Object" : "";
			var tag = (isPlainObject$3 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "") + (stringTag$1 || protoTag ? "[" + $join.call($concat$1.call([], stringTag$1 || [], protoTag || []), ": ") + "] " : "");
			if (ys.length === 0) return tag + "{}";
			if (indent) return tag + "{" + indentedJoin(ys, indent) + "}";
			return tag + "{ " + $join.call(ys, ", ") + " }";
		}
		return String(obj);
	};
	function wrapQuotes(s, defaultStyle, opts) {
		var quoteChar = quotes[opts.quoteStyle || defaultStyle];
		return quoteChar + s + quoteChar;
	}
	function quote(s) {
		return $replace$1.call(String(s), /"/g, "&quot;");
	}
	function canTrustToString(obj) {
		return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
	}
	function isArray$3(obj) {
		return toStr$1(obj) === "[object Array]" && canTrustToString(obj);
	}
	function isDate(obj) {
		return toStr$1(obj) === "[object Date]" && canTrustToString(obj);
	}
	function isRegExp$1(obj) {
		return toStr$1(obj) === "[object RegExp]" && canTrustToString(obj);
	}
	function isError(obj) {
		return toStr$1(obj) === "[object Error]" && canTrustToString(obj);
	}
	function isString(obj) {
		return toStr$1(obj) === "[object String]" && canTrustToString(obj);
	}
	function isNumber(obj) {
		return toStr$1(obj) === "[object Number]" && canTrustToString(obj);
	}
	function isBoolean(obj) {
		return toStr$1(obj) === "[object Boolean]" && canTrustToString(obj);
	}
	function isSymbol(obj) {
		if (hasShammedSymbols) return obj && typeof obj === "object" && obj instanceof Symbol;
		if (typeof obj === "symbol") return true;
		if (!obj || typeof obj !== "object" || !symToString) return false;
		try {
			symToString.call(obj);
			return true;
		} catch (e) {}
		return false;
	}
	function isBigInt(obj) {
		if (!obj || typeof obj !== "object" || !bigIntValueOf) return false;
		try {
			bigIntValueOf.call(obj);
			return true;
		} catch (e) {}
		return false;
	}
	var hasOwn$1 = Object.prototype.hasOwnProperty || function(key) {
		return key in this;
	};
	function has$3(obj, key) {
		return hasOwn$1.call(obj, key);
	}
	function toStr$1(obj) {
		return objectToString.call(obj);
	}
	function nameOf(f) {
		if (f.name) return f.name;
		var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
		if (m) return m[1];
		return null;
	}
	function indexOf(xs, x$1) {
		if (xs.indexOf) return xs.indexOf(x$1);
		for (var i = 0, l = xs.length; i < l; i++) if (xs[i] === x$1) return i;
		return -1;
	}
	function isMap(x$1) {
		if (!mapSize || !x$1 || typeof x$1 !== "object") return false;
		try {
			mapSize.call(x$1);
			try {
				setSize.call(x$1);
			} catch (s) {
				return true;
			}
			return x$1 instanceof Map;
		} catch (e) {}
		return false;
	}
	function isWeakMap(x$1) {
		if (!weakMapHas || !x$1 || typeof x$1 !== "object") return false;
		try {
			weakMapHas.call(x$1, weakMapHas);
			try {
				weakSetHas.call(x$1, weakSetHas);
			} catch (s) {
				return true;
			}
			return x$1 instanceof WeakMap;
		} catch (e) {}
		return false;
	}
	function isWeakRef(x$1) {
		if (!weakRefDeref || !x$1 || typeof x$1 !== "object") return false;
		try {
			weakRefDeref.call(x$1);
			return true;
		} catch (e) {}
		return false;
	}
	function isSet(x$1) {
		if (!setSize || !x$1 || typeof x$1 !== "object") return false;
		try {
			setSize.call(x$1);
			try {
				mapSize.call(x$1);
			} catch (m) {
				return true;
			}
			return x$1 instanceof Set;
		} catch (e) {}
		return false;
	}
	function isWeakSet(x$1) {
		if (!weakSetHas || !x$1 || typeof x$1 !== "object") return false;
		try {
			weakSetHas.call(x$1, weakSetHas);
			try {
				weakMapHas.call(x$1, weakMapHas);
			} catch (s) {
				return true;
			}
			return x$1 instanceof WeakSet;
		} catch (e) {}
		return false;
	}
	function isElement(x$1) {
		if (!x$1 || typeof x$1 !== "object") return false;
		if (typeof HTMLElement !== "undefined" && x$1 instanceof HTMLElement) return true;
		return typeof x$1.nodeName === "string" && typeof x$1.getAttribute === "function";
	}
	function inspectString(str, opts) {
		if (str.length > opts.maxStringLength) {
			var remaining = str.length - opts.maxStringLength;
			var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
			return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
		}
		var quoteRE = quoteREs[opts.quoteStyle || "single"];
		quoteRE.lastIndex = 0;
		return wrapQuotes($replace$1.call($replace$1.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte), "single", opts);
	}
	function lowbyte(c) {
		var n = c.charCodeAt(0);
		var x$1 = {
			8: "b",
			9: "t",
			10: "n",
			12: "f",
			13: "r"
		}[n];
		if (x$1) return "\\" + x$1;
		return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
	}
	function markBoxed(str) {
		return "Object(" + str + ")";
	}
	function weakCollectionOf(type) {
		return type + " { ? }";
	}
	function collectionOf(type, size, entries, indent) {
		var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
		return type + " (" + size + ") {" + joinedEntries + "}";
	}
	function singleLineValues(xs) {
		for (var i = 0; i < xs.length; i++) if (indexOf(xs[i], "\n") >= 0) return false;
		return true;
	}
	function getIndent(opts, depth) {
		var baseIndent;
		if (opts.indent === "	") baseIndent = "	";
		else if (typeof opts.indent === "number" && opts.indent > 0) baseIndent = $join.call(Array(opts.indent + 1), " ");
		else return null;
		return {
			base: baseIndent,
			prev: $join.call(Array(depth + 1), baseIndent)
		};
	}
	function indentedJoin(xs, indent) {
		if (xs.length === 0) return "";
		var lineJoiner = "\n" + indent.prev + indent.base;
		return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
	}
	function arrObjKeys(obj, inspect$4) {
		var isArr = isArray$3(obj);
		var xs = [];
		if (isArr) {
			xs.length = obj.length;
			for (var i = 0; i < obj.length; i++) xs[i] = has$3(obj, i) ? inspect$4(obj[i], obj) : "";
		}
		var syms = typeof gOPS === "function" ? gOPS(obj) : [];
		var symMap;
		if (hasShammedSymbols) {
			symMap = {};
			for (var k$1 = 0; k$1 < syms.length; k$1++) symMap["$" + syms[k$1]] = syms[k$1];
		}
		for (var key in obj) {
			if (!has$3(obj, key)) continue;
			if (isArr && String(Number(key)) === key && key < obj.length) continue;
			if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) continue;
			else if ($test.call(/[^\w$]/, key)) xs.push(inspect$4(key, obj) + ": " + inspect$4(obj[key], obj));
			else xs.push(key + ": " + inspect$4(obj[key], obj));
		}
		if (typeof gOPS === "function") {
			for (var j$1 = 0; j$1 < syms.length; j$1++) if (isEnumerable.call(obj, syms[j$1])) xs.push("[" + inspect$4(syms[j$1]) + "]: " + inspect$4(obj[syms[j$1]], obj));
		}
		return xs;
	}
}) });

//#endregion
//#region node_modules/side-channel-list/index.js
var require_side_channel_list = /* @__PURE__ */ __commonJS({ "node_modules/side-channel-list/index.js": ((exports, module) => {
	var inspect$3 = require_object_inspect();
	var $TypeError$5 = require_type();
	/** @type {import('./list.d.ts').listGetNode} */
	var listGetNode = function(list, key, isDelete) {
		/** @type {typeof list | NonNullable<(typeof list)['next']>} */
		var prev = list;
		/** @type {(typeof list)['next']} */
		var curr;
		for (; (curr = prev.next) != null; prev = curr) if (curr.key === key) {
			prev.next = curr.next;
			if (!isDelete) {
				curr.next = list.next;
				list.next = curr;
			}
			return curr;
		}
	};
	/** @type {import('./list.d.ts').listGet} */
	var listGet = function(objects, key) {
		if (!objects) return;
		var node = listGetNode(objects, key);
		return node && node.value;
	};
	/** @type {import('./list.d.ts').listSet} */
	var listSet = function(objects, key, value) {
		var node = listGetNode(objects, key);
		if (node) node.value = value;
		else objects.next = {
			key,
			next: objects.next,
			value
		};
	};
	/** @type {import('./list.d.ts').listHas} */
	var listHas = function(objects, key) {
		if (!objects) return false;
		return !!listGetNode(objects, key);
	};
	/** @type {import('./list.d.ts').listDelete} */
	var listDelete = function(objects, key) {
		if (objects) return listGetNode(objects, key, true);
	};
	/** @type {import('.')} */
	module.exports = function getSideChannelList$1() {
		/** @typedef {ReturnType<typeof getSideChannelList>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */
		/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;
		/** @type {Channel} */
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError$5("Side channel does not contain " + inspect$3(key));
			},
			"delete": function(key) {
				var root$1 = $o && $o.next;
				var deletedNode = listDelete($o, key);
				if (deletedNode && root$1 && root$1 === deletedNode) $o = void 0;
				return !!deletedNode;
			},
			get: function(key) {
				return listGet($o, key);
			},
			has: function(key) {
				return listHas($o, key);
			},
			set: function(key, value) {
				if (!$o) $o = { next: void 0 };
				listSet($o, key, value);
			}
		};
		return channel;
	};
}) });

//#endregion
//#region node_modules/es-object-atoms/index.js
var require_es_object_atoms = /* @__PURE__ */ __commonJS({ "node_modules/es-object-atoms/index.js": ((exports, module) => {
	/** @type {import('.')} */
	module.exports = Object;
}) });

//#endregion
//#region node_modules/es-errors/index.js
var require_es_errors = /* @__PURE__ */ __commonJS({ "node_modules/es-errors/index.js": ((exports, module) => {
	/** @type {import('.')} */
	module.exports = Error;
}) });

//#endregion
//#region node_modules/es-errors/eval.js
var require_eval = /* @__PURE__ */ __commonJS({ "node_modules/es-errors/eval.js": ((exports, module) => {
	/** @type {import('./eval')} */
	module.exports = EvalError;
}) });

//#endregion
//#region node_modules/es-errors/range.js
var require_range = /* @__PURE__ */ __commonJS({ "node_modules/es-errors/range.js": ((exports, module) => {
	/** @type {import('./range')} */
	module.exports = RangeError;
}) });

//#endregion
//#region node_modules/es-errors/ref.js
var require_ref = /* @__PURE__ */ __commonJS({ "node_modules/es-errors/ref.js": ((exports, module) => {
	/** @type {import('./ref')} */
	module.exports = ReferenceError;
}) });

//#endregion
//#region node_modules/es-errors/syntax.js
var require_syntax = /* @__PURE__ */ __commonJS({ "node_modules/es-errors/syntax.js": ((exports, module) => {
	/** @type {import('./syntax')} */
	module.exports = SyntaxError;
}) });

//#endregion
//#region node_modules/es-errors/uri.js
var require_uri = /* @__PURE__ */ __commonJS({ "node_modules/es-errors/uri.js": ((exports, module) => {
	/** @type {import('./uri')} */
	module.exports = URIError;
}) });

//#endregion
//#region node_modules/math-intrinsics/abs.js
var require_abs = /* @__PURE__ */ __commonJS({ "node_modules/math-intrinsics/abs.js": ((exports, module) => {
	/** @type {import('./abs')} */
	module.exports = Math.abs;
}) });

//#endregion
//#region node_modules/math-intrinsics/floor.js
var require_floor = /* @__PURE__ */ __commonJS({ "node_modules/math-intrinsics/floor.js": ((exports, module) => {
	/** @type {import('./floor')} */
	module.exports = Math.floor;
}) });

//#endregion
//#region node_modules/math-intrinsics/max.js
var require_max = /* @__PURE__ */ __commonJS({ "node_modules/math-intrinsics/max.js": ((exports, module) => {
	/** @type {import('./max')} */
	module.exports = Math.max;
}) });

//#endregion
//#region node_modules/math-intrinsics/min.js
var require_min = /* @__PURE__ */ __commonJS({ "node_modules/math-intrinsics/min.js": ((exports, module) => {
	/** @type {import('./min')} */
	module.exports = Math.min;
}) });

//#endregion
//#region node_modules/math-intrinsics/pow.js
var require_pow = /* @__PURE__ */ __commonJS({ "node_modules/math-intrinsics/pow.js": ((exports, module) => {
	/** @type {import('./pow')} */
	module.exports = Math.pow;
}) });

//#endregion
//#region node_modules/math-intrinsics/round.js
var require_round = /* @__PURE__ */ __commonJS({ "node_modules/math-intrinsics/round.js": ((exports, module) => {
	/** @type {import('./round')} */
	module.exports = Math.round;
}) });

//#endregion
//#region node_modules/math-intrinsics/isNaN.js
var require_isNaN = /* @__PURE__ */ __commonJS({ "node_modules/math-intrinsics/isNaN.js": ((exports, module) => {
	/** @type {import('./isNaN')} */
	module.exports = Number.isNaN || function isNaN$1(a) {
		return a !== a;
	};
}) });

//#endregion
//#region node_modules/math-intrinsics/sign.js
var require_sign = /* @__PURE__ */ __commonJS({ "node_modules/math-intrinsics/sign.js": ((exports, module) => {
	var $isNaN = require_isNaN();
	/** @type {import('./sign')} */
	module.exports = function sign$1(number) {
		if ($isNaN(number) || number === 0) return number;
		return number < 0 ? -1 : 1;
	};
}) });

//#endregion
//#region node_modules/gopd/gOPD.js
var require_gOPD = /* @__PURE__ */ __commonJS({ "node_modules/gopd/gOPD.js": ((exports, module) => {
	/** @type {import('./gOPD')} */
	module.exports = Object.getOwnPropertyDescriptor;
}) });

//#endregion
//#region node_modules/gopd/index.js
var require_gopd = /* @__PURE__ */ __commonJS({ "node_modules/gopd/index.js": ((exports, module) => {
	/** @type {import('.')} */
	var $gOPD$1 = require_gOPD();
	if ($gOPD$1) try {
		$gOPD$1([], "length");
	} catch (e) {
		$gOPD$1 = null;
	}
	module.exports = $gOPD$1;
}) });

//#endregion
//#region node_modules/es-define-property/index.js
var require_es_define_property = /* @__PURE__ */ __commonJS({ "node_modules/es-define-property/index.js": ((exports, module) => {
	/** @type {import('.')} */
	var $defineProperty$1 = Object.defineProperty || false;
	if ($defineProperty$1) try {
		$defineProperty$1({}, "a", { value: 1 });
	} catch (e) {
		$defineProperty$1 = false;
	}
	module.exports = $defineProperty$1;
}) });

//#endregion
//#region node_modules/has-symbols/shams.js
var require_shams = /* @__PURE__ */ __commonJS({ "node_modules/has-symbols/shams.js": ((exports, module) => {
	/** @type {import('./shams')} */
	module.exports = function hasSymbols$1() {
		if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return false;
		if (typeof Symbol.iterator === "symbol") return true;
		/** @type {{ [k in symbol]?: unknown }} */
		var obj = {};
		var sym = Symbol("test");
		var symObj = Object(sym);
		if (typeof sym === "string") return false;
		if (Object.prototype.toString.call(sym) !== "[object Symbol]") return false;
		if (Object.prototype.toString.call(symObj) !== "[object Symbol]") return false;
		var symVal = 42;
		obj[sym] = symVal;
		for (var _$1 in obj) return false;
		if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) return false;
		if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) return false;
		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) return false;
		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
		if (typeof Object.getOwnPropertyDescriptor === "function") {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
		}
		return true;
	};
}) });

//#endregion
//#region node_modules/has-symbols/index.js
var require_has_symbols = /* @__PURE__ */ __commonJS({ "node_modules/has-symbols/index.js": ((exports, module) => {
	var origSymbol = typeof Symbol !== "undefined" && Symbol;
	var hasSymbolSham = require_shams();
	/** @type {import('.')} */
	module.exports = function hasNativeSymbols() {
		if (typeof origSymbol !== "function") return false;
		if (typeof Symbol !== "function") return false;
		if (typeof origSymbol("foo") !== "symbol") return false;
		if (typeof Symbol("bar") !== "symbol") return false;
		return hasSymbolSham();
	};
}) });

//#endregion
//#region node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = /* @__PURE__ */ __commonJS({ "node_modules/get-proto/Reflect.getPrototypeOf.js": ((exports, module) => {
	/** @type {import('./Reflect.getPrototypeOf')} */
	module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
}) });

//#endregion
//#region node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = /* @__PURE__ */ __commonJS({ "node_modules/get-proto/Object.getPrototypeOf.js": ((exports, module) => {
	var $Object$2 = require_es_object_atoms();
	/** @type {import('./Object.getPrototypeOf')} */
	module.exports = $Object$2.getPrototypeOf || null;
}) });

//#endregion
//#region node_modules/function-bind/implementation.js
var require_implementation = /* @__PURE__ */ __commonJS({ "node_modules/function-bind/implementation.js": ((exports, module) => {
	var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
	var toStr = Object.prototype.toString;
	var max$1 = Math.max;
	var funcType = "[object Function]";
	var concatty = function concatty$1(a, b$1) {
		var arr = [];
		for (var i = 0; i < a.length; i += 1) arr[i] = a[i];
		for (var j$1 = 0; j$1 < b$1.length; j$1 += 1) arr[j$1 + a.length] = b$1[j$1];
		return arr;
	};
	var slicy = function slicy$1(arrLike, offset) {
		var arr = [];
		for (var i = offset || 0, j$1 = 0; i < arrLike.length; i += 1, j$1 += 1) arr[j$1] = arrLike[i];
		return arr;
	};
	var joiny = function(arr, joiner) {
		var str = "";
		for (var i = 0; i < arr.length; i += 1) {
			str += arr[i];
			if (i + 1 < arr.length) str += joiner;
		}
		return str;
	};
	module.exports = function bind$5(that) {
		var target = this;
		if (typeof target !== "function" || toStr.apply(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
		var args = slicy(arguments, 1);
		var bound;
		var binder = function() {
			if (this instanceof bound) {
				var result = target.apply(this, concatty(args, arguments));
				if (Object(result) === result) return result;
				return this;
			}
			return target.apply(that, concatty(args, arguments));
		};
		var boundLength = max$1(0, target.length - args.length);
		var boundArgs = [];
		for (var i = 0; i < boundLength; i++) boundArgs[i] = "$" + i;
		bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
		if (target.prototype) {
			var Empty = function Empty$1() {};
			Empty.prototype = target.prototype;
			bound.prototype = new Empty();
			Empty.prototype = null;
		}
		return bound;
	};
}) });

//#endregion
//#region node_modules/function-bind/index.js
var require_function_bind = /* @__PURE__ */ __commonJS({ "node_modules/function-bind/index.js": ((exports, module) => {
	var implementation = require_implementation();
	module.exports = Function.prototype.bind || implementation;
}) });

//#endregion
//#region node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = /* @__PURE__ */ __commonJS({ "node_modules/call-bind-apply-helpers/functionCall.js": ((exports, module) => {
	/** @type {import('./functionCall')} */
	module.exports = Function.prototype.call;
}) });

//#endregion
//#region node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = /* @__PURE__ */ __commonJS({ "node_modules/call-bind-apply-helpers/functionApply.js": ((exports, module) => {
	/** @type {import('./functionApply')} */
	module.exports = Function.prototype.apply;
}) });

//#endregion
//#region node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = /* @__PURE__ */ __commonJS({ "node_modules/call-bind-apply-helpers/reflectApply.js": ((exports, module) => {
	/** @type {import('./reflectApply')} */
	module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
}) });

//#endregion
//#region node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = /* @__PURE__ */ __commonJS({ "node_modules/call-bind-apply-helpers/actualApply.js": ((exports, module) => {
	var bind$3 = require_function_bind();
	var $apply$1 = require_functionApply();
	var $call$2 = require_functionCall();
	var $reflectApply = require_reflectApply();
	/** @type {import('./actualApply')} */
	module.exports = $reflectApply || bind$3.call($call$2, $apply$1);
}) });

//#endregion
//#region node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = /* @__PURE__ */ __commonJS({ "node_modules/call-bind-apply-helpers/index.js": ((exports, module) => {
	var bind$2 = require_function_bind();
	var $TypeError$4 = require_type();
	var $call$1 = require_functionCall();
	var $actualApply = require_actualApply();
	/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
	module.exports = function callBindBasic$1(args) {
		if (args.length < 1 || typeof args[0] !== "function") throw new $TypeError$4("a function is required");
		return $actualApply(bind$2, $call$1, args);
	};
}) });

//#endregion
//#region node_modules/dunder-proto/get.js
var require_get = /* @__PURE__ */ __commonJS({ "node_modules/dunder-proto/get.js": ((exports, module) => {
	var callBind = require_call_bind_apply_helpers();
	var gOPD = require_gopd();
	var hasProtoAccessor;
	try {
		hasProtoAccessor = [].__proto__ === Array.prototype;
	} catch (e) {
		if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") throw e;
	}
	var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
	var $Object$1 = Object;
	var $getPrototypeOf = $Object$1.getPrototypeOf;
	/** @type {import('./get')} */
	module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
		return $getPrototypeOf(value == null ? value : $Object$1(value));
	} : false;
}) });

//#endregion
//#region node_modules/get-proto/index.js
var require_get_proto = /* @__PURE__ */ __commonJS({ "node_modules/get-proto/index.js": ((exports, module) => {
	var reflectGetProto = require_Reflect_getPrototypeOf();
	var originalGetProto = require_Object_getPrototypeOf();
	var getDunderProto = require_get();
	/** @type {import('.')} */
	module.exports = reflectGetProto ? function getProto$1(O$1) {
		return reflectGetProto(O$1);
	} : originalGetProto ? function getProto$1(O$1) {
		if (!O$1 || typeof O$1 !== "object" && typeof O$1 !== "function") throw new TypeError("getProto: not an object");
		return originalGetProto(O$1);
	} : getDunderProto ? function getProto$1(O$1) {
		return getDunderProto(O$1);
	} : null;
}) });

//#endregion
//#region node_modules/hasown/index.js
var require_hasown = /* @__PURE__ */ __commonJS({ "node_modules/hasown/index.js": ((exports, module) => {
	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind$1 = require_function_bind();
	/** @type {import('.')} */
	module.exports = bind$1.call(call, $hasOwn);
}) });

//#endregion
//#region node_modules/get-intrinsic/index.js
var require_get_intrinsic = /* @__PURE__ */ __commonJS({ "node_modules/get-intrinsic/index.js": ((exports, module) => {
	var undefined$1;
	var $Object = require_es_object_atoms();
	var $Error = require_es_errors();
	var $EvalError = require_eval();
	var $RangeError = require_range();
	var $ReferenceError = require_ref();
	var $SyntaxError = require_syntax();
	var $TypeError$3 = require_type();
	var $URIError = require_uri();
	var abs = require_abs();
	var floor = require_floor();
	var max = require_max();
	var min = require_min();
	var pow = require_pow();
	var round = require_round();
	var sign = require_sign();
	var $Function = Function;
	var getEvalledConstructor = function(expressionSyntax) {
		try {
			return $Function("\"use strict\"; return (" + expressionSyntax + ").constructor;")();
		} catch (e) {}
	};
	var $gOPD = require_gopd();
	var $defineProperty = require_es_define_property();
	var throwTypeError = function() {
		throw new $TypeError$3();
	};
	var ThrowTypeError = $gOPD ? function() {
		try {
			arguments.callee;
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				return $gOPD(arguments, "callee").get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}() : throwTypeError;
	var hasSymbols = require_has_symbols()();
	var getProto = require_get_proto();
	var $ObjectGPO = require_Object_getPrototypeOf();
	var $ReflectGPO = require_Reflect_getPrototypeOf();
	var $apply = require_functionApply();
	var $call = require_functionCall();
	var needsEval = {};
	var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
	var INTRINSICS = {
		__proto__: null,
		"%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
		"%Array%": Array,
		"%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
		"%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
		"%AsyncFromSyncIteratorPrototype%": undefined$1,
		"%AsyncFunction%": needsEval,
		"%AsyncGenerator%": needsEval,
		"%AsyncGeneratorFunction%": needsEval,
		"%AsyncIteratorPrototype%": needsEval,
		"%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
		"%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
		"%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
		"%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
		"%Boolean%": Boolean,
		"%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
		"%Date%": Date,
		"%decodeURI%": decodeURI,
		"%decodeURIComponent%": decodeURIComponent,
		"%encodeURI%": encodeURI,
		"%encodeURIComponent%": encodeURIComponent,
		"%Error%": $Error,
		"%eval%": eval,
		"%EvalError%": $EvalError,
		"%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
		"%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
		"%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
		"%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
		"%Function%": $Function,
		"%GeneratorFunction%": needsEval,
		"%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
		"%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
		"%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
		"%isFinite%": isFinite,
		"%isNaN%": isNaN,
		"%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
		"%JSON%": typeof JSON === "object" ? JSON : undefined$1,
		"%Map%": typeof Map === "undefined" ? undefined$1 : Map,
		"%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
		"%Math%": Math,
		"%Number%": Number,
		"%Object%": $Object,
		"%Object.getOwnPropertyDescriptor%": $gOPD,
		"%parseFloat%": parseFloat,
		"%parseInt%": parseInt,
		"%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
		"%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
		"%RangeError%": $RangeError,
		"%ReferenceError%": $ReferenceError,
		"%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
		"%RegExp%": RegExp,
		"%Set%": typeof Set === "undefined" ? undefined$1 : Set,
		"%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
		"%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
		"%String%": String,
		"%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
		"%Symbol%": hasSymbols ? Symbol : undefined$1,
		"%SyntaxError%": $SyntaxError,
		"%ThrowTypeError%": ThrowTypeError,
		"%TypedArray%": TypedArray,
		"%TypeError%": $TypeError$3,
		"%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
		"%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
		"%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
		"%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
		"%URIError%": $URIError,
		"%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
		"%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
		"%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
		"%Function.prototype.call%": $call,
		"%Function.prototype.apply%": $apply,
		"%Object.defineProperty%": $defineProperty,
		"%Object.getPrototypeOf%": $ObjectGPO,
		"%Math.abs%": abs,
		"%Math.floor%": floor,
		"%Math.max%": max,
		"%Math.min%": min,
		"%Math.pow%": pow,
		"%Math.round%": round,
		"%Math.sign%": sign,
		"%Reflect.getPrototypeOf%": $ReflectGPO
	};
	if (getProto) try {
		null.error;
	} catch (e) {
		INTRINSICS["%Error.prototype%"] = getProto(getProto(e));
	}
	var doEval = function doEval$1(name) {
		var value;
		if (name === "%AsyncFunction%") value = getEvalledConstructor("async function () {}");
		else if (name === "%GeneratorFunction%") value = getEvalledConstructor("function* () {}");
		else if (name === "%AsyncGeneratorFunction%") value = getEvalledConstructor("async function* () {}");
		else if (name === "%AsyncGenerator%") {
			var fn = doEval$1("%AsyncGeneratorFunction%");
			if (fn) value = fn.prototype;
		} else if (name === "%AsyncIteratorPrototype%") {
			var gen = doEval$1("%AsyncGenerator%");
			if (gen && getProto) value = getProto(gen.prototype);
		}
		INTRINSICS[name] = value;
		return value;
	};
	var LEGACY_ALIASES = {
		__proto__: null,
		"%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
		"%ArrayPrototype%": ["Array", "prototype"],
		"%ArrayProto_entries%": [
			"Array",
			"prototype",
			"entries"
		],
		"%ArrayProto_forEach%": [
			"Array",
			"prototype",
			"forEach"
		],
		"%ArrayProto_keys%": [
			"Array",
			"prototype",
			"keys"
		],
		"%ArrayProto_values%": [
			"Array",
			"prototype",
			"values"
		],
		"%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
		"%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
		"%AsyncGeneratorPrototype%": [
			"AsyncGeneratorFunction",
			"prototype",
			"prototype"
		],
		"%BooleanPrototype%": ["Boolean", "prototype"],
		"%DataViewPrototype%": ["DataView", "prototype"],
		"%DatePrototype%": ["Date", "prototype"],
		"%ErrorPrototype%": ["Error", "prototype"],
		"%EvalErrorPrototype%": ["EvalError", "prototype"],
		"%Float32ArrayPrototype%": ["Float32Array", "prototype"],
		"%Float64ArrayPrototype%": ["Float64Array", "prototype"],
		"%FunctionPrototype%": ["Function", "prototype"],
		"%Generator%": ["GeneratorFunction", "prototype"],
		"%GeneratorPrototype%": [
			"GeneratorFunction",
			"prototype",
			"prototype"
		],
		"%Int8ArrayPrototype%": ["Int8Array", "prototype"],
		"%Int16ArrayPrototype%": ["Int16Array", "prototype"],
		"%Int32ArrayPrototype%": ["Int32Array", "prototype"],
		"%JSONParse%": ["JSON", "parse"],
		"%JSONStringify%": ["JSON", "stringify"],
		"%MapPrototype%": ["Map", "prototype"],
		"%NumberPrototype%": ["Number", "prototype"],
		"%ObjectPrototype%": ["Object", "prototype"],
		"%ObjProto_toString%": [
			"Object",
			"prototype",
			"toString"
		],
		"%ObjProto_valueOf%": [
			"Object",
			"prototype",
			"valueOf"
		],
		"%PromisePrototype%": ["Promise", "prototype"],
		"%PromiseProto_then%": [
			"Promise",
			"prototype",
			"then"
		],
		"%Promise_all%": ["Promise", "all"],
		"%Promise_reject%": ["Promise", "reject"],
		"%Promise_resolve%": ["Promise", "resolve"],
		"%RangeErrorPrototype%": ["RangeError", "prototype"],
		"%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
		"%RegExpPrototype%": ["RegExp", "prototype"],
		"%SetPrototype%": ["Set", "prototype"],
		"%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
		"%StringPrototype%": ["String", "prototype"],
		"%SymbolPrototype%": ["Symbol", "prototype"],
		"%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
		"%TypedArrayPrototype%": ["TypedArray", "prototype"],
		"%TypeErrorPrototype%": ["TypeError", "prototype"],
		"%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
		"%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
		"%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
		"%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
		"%URIErrorPrototype%": ["URIError", "prototype"],
		"%WeakMapPrototype%": ["WeakMap", "prototype"],
		"%WeakSetPrototype%": ["WeakSet", "prototype"]
	};
	var bind = require_function_bind();
	var hasOwn = require_hasown();
	var $concat = bind.call($call, Array.prototype.concat);
	var $spliceApply = bind.call($apply, Array.prototype.splice);
	var $replace = bind.call($call, String.prototype.replace);
	var $strSlice = bind.call($call, String.prototype.slice);
	var $exec = bind.call($call, RegExp.prototype.exec);
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g;
	var stringToPath = function stringToPath$1(string) {
		var first = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first === "%" && last !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
		else if (last === "%" && first !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
		var result = [];
		$replace(string, rePropName, function(match, number, quote$1, subString) {
			result[result.length] = quote$1 ? $replace(subString, reEscapeChar, "$1") : number || match;
		});
		return result;
	};
	var getBaseIntrinsic = function getBaseIntrinsic$1(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = "%" + alias[0] + "%";
		}
		if (hasOwn(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) value = doEval(intrinsicName);
			if (typeof value === "undefined" && !allowMissing) throw new $TypeError$3("intrinsic " + name + " exists, but is not available. Please file an issue!");
			return {
				alias,
				name: intrinsicName,
				value
			};
		}
		throw new $SyntaxError("intrinsic " + name + " does not exist!");
	};
	module.exports = function GetIntrinsic$3(name, allowMissing) {
		if (typeof name !== "string" || name.length === 0) throw new $TypeError$3("intrinsic name must be a non-empty string");
		if (arguments.length > 1 && typeof allowMissing !== "boolean") throw new $TypeError$3("\"allowMissing\" argument must be a boolean");
		if ($exec(/^%?[^%]*%?$/, name) === null) throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
		var parts = stringToPath(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
		var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;
		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}
		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if ((first === "\"" || first === "'" || first === "`" || last === "\"" || last === "'" || last === "`") && first !== last) throw new $SyntaxError("property names with quotes must have matching quotes");
			if (part === "constructor" || !isOwn) skipFurtherCaching = true;
			intrinsicBaseName += "." + part;
			intrinsicRealName = "%" + intrinsicBaseName + "%";
			if (hasOwn(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
			else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) throw new $TypeError$3("base intrinsic for " + name + " exists, but the property is not available.");
					return;
				}
				if ($gOPD && i + 1 >= parts.length) {
					var desc$1 = $gOPD(value, part);
					isOwn = !!desc$1;
					if (isOwn && "get" in desc$1 && !("originalValue" in desc$1.get)) value = desc$1.get;
					else value = value[part];
				} else {
					isOwn = hasOwn(value, part);
					value = value[part];
				}
				if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
			}
		}
		return value;
	};
}) });

//#endregion
//#region node_modules/call-bound/index.js
var require_call_bound = /* @__PURE__ */ __commonJS({ "node_modules/call-bound/index.js": ((exports, module) => {
	var GetIntrinsic$2 = require_get_intrinsic();
	var callBindBasic = require_call_bind_apply_helpers();
	/** @type {(thisArg: string, searchString: string, position?: number) => number} */
	var $indexOf = callBindBasic([GetIntrinsic$2("%String.prototype.indexOf%")]);
	/** @type {import('.')} */
	module.exports = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic$2(name, !!allowMissing);
		if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) return callBindBasic([intrinsic]);
		return intrinsic;
	};
}) });

//#endregion
//#region node_modules/side-channel-map/index.js
var require_side_channel_map = /* @__PURE__ */ __commonJS({ "node_modules/side-channel-map/index.js": ((exports, module) => {
	var GetIntrinsic$1 = require_get_intrinsic();
	var callBound$1 = require_call_bound();
	var inspect$2 = require_object_inspect();
	var $TypeError$2 = require_type();
	var $Map = GetIntrinsic$1("%Map%", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
	var $mapGet = callBound$1("Map.prototype.get", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
	var $mapSet = callBound$1("Map.prototype.set", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
	var $mapHas = callBound$1("Map.prototype.has", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
	var $mapDelete = callBound$1("Map.prototype.delete", true);
	/** @type {<K, V>(thisArg: Map<K, V>) => number} */
	var $mapSize = callBound$1("Map.prototype.size", true);
	/** @type {import('.')} */
	module.exports = !!$Map && function getSideChannelMap$2() {
		/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */
		/** @type {Map<K, V> | undefined} */ var $m;
		/** @type {Channel} */
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError$2("Side channel does not contain " + inspect$2(key));
			},
			"delete": function(key) {
				if ($m) {
					var result = $mapDelete($m, key);
					if ($mapSize($m) === 0) $m = void 0;
					return result;
				}
				return false;
			},
			get: function(key) {
				if ($m) return $mapGet($m, key);
			},
			has: function(key) {
				if ($m) return $mapHas($m, key);
				return false;
			},
			set: function(key, value) {
				if (!$m) $m = new $Map();
				$mapSet($m, key, value);
			}
		};
		return channel;
	};
}) });

//#endregion
//#region node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = /* @__PURE__ */ __commonJS({ "node_modules/side-channel-weakmap/index.js": ((exports, module) => {
	var GetIntrinsic = require_get_intrinsic();
	var callBound = require_call_bound();
	var inspect$1 = require_object_inspect();
	var getSideChannelMap$1 = require_side_channel_map();
	var $TypeError$1 = require_type();
	var $WeakMap = GetIntrinsic("%WeakMap%", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
	var $weakMapGet = callBound("WeakMap.prototype.get", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
	var $weakMapSet = callBound("WeakMap.prototype.set", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
	var $weakMapHas = callBound("WeakMap.prototype.has", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
	var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
	/** @type {import('.')} */
	module.exports = $WeakMap ? function getSideChannelWeakMap() {
		/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */
		/** @type {WeakMap<K & object, V> | undefined} */ var $wm;
		/** @type {Channel | undefined} */ var $m;
		/** @type {Channel} */
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError$1("Side channel does not contain " + inspect$1(key));
			},
			"delete": function(key) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if ($wm) return $weakMapDelete($wm, key);
				} else if (getSideChannelMap$1) {
					if ($m) return $m["delete"](key);
				}
				return false;
			},
			get: function(key) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if ($wm) return $weakMapGet($wm, key);
				}
				return $m && $m.get(key);
			},
			has: function(key) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if ($wm) return $weakMapHas($wm, key);
				}
				return !!$m && $m.has(key);
			},
			set: function(key, value) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if (!$wm) $wm = new $WeakMap();
					$weakMapSet($wm, key, value);
				} else if (getSideChannelMap$1) {
					if (!$m) $m = getSideChannelMap$1();
					/** @type {NonNullable<typeof $m>} */ $m.set(key, value);
				}
			}
		};
		return channel;
	} : getSideChannelMap$1;
}) });

//#endregion
//#region node_modules/side-channel/index.js
var require_side_channel = /* @__PURE__ */ __commonJS({ "node_modules/side-channel/index.js": ((exports, module) => {
	var $TypeError = require_type();
	var inspect = require_object_inspect();
	var getSideChannelList = require_side_channel_list();
	var getSideChannelMap = require_side_channel_map();
	var makeChannel = require_side_channel_weakmap() || getSideChannelMap || getSideChannelList;
	/** @type {import('.')} */
	module.exports = function getSideChannel$2() {
		/** @typedef {ReturnType<typeof getSideChannel>} Channel */
		/** @type {Channel | undefined} */ var $channelData;
		/** @type {Channel} */
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				return !!$channelData && $channelData["delete"](key);
			},
			get: function(key) {
				return $channelData && $channelData.get(key);
			},
			has: function(key) {
				return !!$channelData && $channelData.has(key);
			},
			set: function(key, value) {
				if (!$channelData) $channelData = makeChannel();
				$channelData.set(key, value);
			}
		};
		return channel;
	};
}) });

//#endregion
//#region node_modules/qs/lib/formats.js
var require_formats = /* @__PURE__ */ __commonJS({ "node_modules/qs/lib/formats.js": ((exports, module) => {
	var replace = String.prototype.replace;
	var percentTwenties = /%20/g;
	var Format = {
		RFC1738: "RFC1738",
		RFC3986: "RFC3986"
	};
	module.exports = {
		"default": Format.RFC3986,
		formatters: {
			RFC1738: function(value) {
				return replace.call(value, percentTwenties, "+");
			},
			RFC3986: function(value) {
				return String(value);
			}
		},
		RFC1738: Format.RFC1738,
		RFC3986: Format.RFC3986
	};
}) });

//#endregion
//#region node_modules/qs/lib/utils.js
var require_utils = /* @__PURE__ */ __commonJS({ "node_modules/qs/lib/utils.js": ((exports, module) => {
	var formats$2 = require_formats();
	var getSideChannel$1 = require_side_channel();
	var has$2 = Object.prototype.hasOwnProperty;
	var isArray$2 = Array.isArray;
	var overflowChannel = getSideChannel$1();
	var markOverflow = function markOverflow$1(obj, maxIndex) {
		overflowChannel.set(obj, maxIndex);
		return obj;
	};
	var isOverflow = function isOverflow$1(obj) {
		return overflowChannel.has(obj);
	};
	var getMaxIndex = function getMaxIndex$1(obj) {
		return overflowChannel.get(obj);
	};
	var setMaxIndex = function setMaxIndex$1(obj, maxIndex) {
		overflowChannel.set(obj, maxIndex);
	};
	var hexTable = function() {
		var array = [];
		for (var i = 0; i < 256; ++i) array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
		return array;
	}();
	var compactQueue = function compactQueue$1(queue$1) {
		while (queue$1.length > 1) {
			var item = queue$1.pop();
			var obj = item.obj[item.prop];
			if (isArray$2(obj)) {
				var compacted = [];
				for (var j$1 = 0; j$1 < obj.length; ++j$1) if (typeof obj[j$1] !== "undefined") compacted.push(obj[j$1]);
				item.obj[item.prop] = compacted;
			}
		}
	};
	var arrayToObject = function arrayToObject$2(source, options) {
		var obj = options && options.plainObjects ? { __proto__: null } : {};
		for (var i = 0; i < source.length; ++i) if (typeof source[i] !== "undefined") obj[i] = source[i];
		return obj;
	};
	var merge = function merge$2(target, source, options) {
		if (!source) return target;
		if (typeof source !== "object" && typeof source !== "function") {
			if (isArray$2(target)) target.push(source);
			else if (target && typeof target === "object") {
				if (isOverflow(target)) {
					var newIndex = getMaxIndex(target) + 1;
					target[newIndex] = source;
					setMaxIndex(target, newIndex);
				} else if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) target[source] = true;
			} else return [target, source];
			return target;
		}
		if (!target || typeof target !== "object") {
			if (isOverflow(source)) {
				var sourceKeys = Object.keys(source);
				var result = options && options.plainObjects ? {
					__proto__: null,
					0: target
				} : { 0: target };
				for (var m = 0; m < sourceKeys.length; m++) {
					var oldKey = parseInt(sourceKeys[m], 10);
					result[oldKey + 1] = source[sourceKeys[m]];
				}
				return markOverflow(result, getMaxIndex(source) + 1);
			}
			return [target].concat(source);
		}
		var mergeTarget = target;
		if (isArray$2(target) && !isArray$2(source)) mergeTarget = arrayToObject(target, options);
		if (isArray$2(target) && isArray$2(source)) {
			source.forEach(function(item, i) {
				if (has$2.call(target, i)) {
					var targetItem = target[i];
					if (targetItem && typeof targetItem === "object" && item && typeof item === "object") target[i] = merge$2(targetItem, item, options);
					else target.push(item);
				} else target[i] = item;
			});
			return target;
		}
		return Object.keys(source).reduce(function(acc, key) {
			var value = source[key];
			if (has$2.call(acc, key)) acc[key] = merge$2(acc[key], value, options);
			else acc[key] = value;
			return acc;
		}, mergeTarget);
	};
	var assign = function assignSingleSource(target, source) {
		return Object.keys(source).reduce(function(acc, key) {
			acc[key] = source[key];
			return acc;
		}, target);
	};
	var decode = function(str, defaultDecoder, charset) {
		var strWithoutPlus = str.replace(/\+/g, " ");
		if (charset === "iso-8859-1") return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
		try {
			return decodeURIComponent(strWithoutPlus);
		} catch (e) {
			return strWithoutPlus;
		}
	};
	var limit = 1024;
	var encode = function encode$3(str, defaultEncoder, charset, kind, format) {
		if (str.length === 0) return str;
		var string = str;
		if (typeof str === "symbol") string = Symbol.prototype.toString.call(str);
		else if (typeof str !== "string") string = String(str);
		if (charset === "iso-8859-1") return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
			return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
		});
		var out = "";
		for (var j$1 = 0; j$1 < string.length; j$1 += limit) {
			var segment = string.length >= limit ? string.slice(j$1, j$1 + limit) : string;
			var arr = [];
			for (var i = 0; i < segment.length; ++i) {
				var c = segment.charCodeAt(i);
				if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats$2.RFC1738 && (c === 40 || c === 41)) {
					arr[arr.length] = segment.charAt(i);
					continue;
				}
				if (c < 128) {
					arr[arr.length] = hexTable[c];
					continue;
				}
				if (c < 2048) {
					arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
					continue;
				}
				if (c < 55296 || c >= 57344) {
					arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
					continue;
				}
				i += 1;
				c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
				arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
			}
			out += arr.join("");
		}
		return out;
	};
	var compact = function compact$1(value) {
		var queue$1 = [{
			obj: { o: value },
			prop: "o"
		}];
		var refs = [];
		for (var i = 0; i < queue$1.length; ++i) {
			var item = queue$1[i];
			var obj = item.obj[item.prop];
			var keys = Object.keys(obj);
			for (var j$1 = 0; j$1 < keys.length; ++j$1) {
				var key = keys[j$1];
				var val = obj[key];
				if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
					queue$1.push({
						obj,
						prop: key
					});
					refs.push(val);
				}
			}
		}
		compactQueue(queue$1);
		return value;
	};
	var isRegExp = function isRegExp$3(obj) {
		return Object.prototype.toString.call(obj) === "[object RegExp]";
	};
	var isBuffer = function isBuffer$2(obj) {
		if (!obj || typeof obj !== "object") return false;
		return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};
	var combine = function combine$1(a, b$1, arrayLimit, plainObjects) {
		if (isOverflow(a)) {
			var newIndex = getMaxIndex(a) + 1;
			a[newIndex] = b$1;
			setMaxIndex(a, newIndex);
			return a;
		}
		var result = [].concat(a, b$1);
		if (result.length > arrayLimit) return markOverflow(arrayToObject(result, { plainObjects }), result.length - 1);
		return result;
	};
	var maybeMap = function maybeMap$1(val, fn) {
		if (isArray$2(val)) {
			var mapped = [];
			for (var i = 0; i < val.length; i += 1) mapped.push(fn(val[i]));
			return mapped;
		}
		return fn(val);
	};
	module.exports = {
		arrayToObject,
		assign,
		combine,
		compact,
		decode,
		encode,
		isBuffer,
		isOverflow,
		isRegExp,
		maybeMap,
		merge
	};
}) });

//#endregion
//#region node_modules/qs/lib/stringify.js
var require_stringify$1 = /* @__PURE__ */ __commonJS({ "node_modules/qs/lib/stringify.js": ((exports, module) => {
	var getSideChannel = require_side_channel();
	var utils$1 = require_utils();
	var formats$1 = require_formats();
	var has$1 = Object.prototype.hasOwnProperty;
	var arrayPrefixGenerators = {
		brackets: function brackets(prefix) {
			return prefix + "[]";
		},
		comma: "comma",
		indices: function indices(prefix, key) {
			return prefix + "[" + key + "]";
		},
		repeat: function repeat(prefix) {
			return prefix;
		}
	};
	var isArray$1 = Array.isArray;
	var push = Array.prototype.push;
	var pushToArray = function(arr, valueOrArray) {
		push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
	};
	var toISO = Date.prototype.toISOString;
	var defaultFormat = formats$1["default"];
	var defaults$1 = {
		addQueryPrefix: false,
		allowDots: false,
		allowEmptyArrays: false,
		arrayFormat: "indices",
		charset: "utf-8",
		charsetSentinel: false,
		commaRoundTrip: false,
		delimiter: "&",
		encode: true,
		encodeDotInKeys: false,
		encoder: utils$1.encode,
		encodeValuesOnly: false,
		filter: void 0,
		format: defaultFormat,
		formatter: formats$1.formatters[defaultFormat],
		indices: false,
		serializeDate: function serializeDate(date) {
			return toISO.call(date);
		},
		skipNulls: false,
		strictNullHandling: false
	};
	var isNonNullishPrimitive = function isNonNullishPrimitive$1(v) {
		return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
	};
	var sentinel = {};
	var stringify$2 = function stringify$3(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
		var obj = object;
		var tmpSc = sideChannel;
		var step = 0;
		var findFlag = false;
		while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
			var pos = tmpSc.get(object);
			step += 1;
			if (typeof pos !== "undefined") if (pos === step) throw new RangeError("Cyclic object value");
			else findFlag = true;
			if (typeof tmpSc.get(sentinel) === "undefined") step = 0;
		}
		if (typeof filter === "function") obj = filter(prefix, obj);
		else if (obj instanceof Date) obj = serializeDate(obj);
		else if (generateArrayPrefix === "comma" && isArray$1(obj)) obj = utils$1.maybeMap(obj, function(value$1) {
			if (value$1 instanceof Date) return serializeDate(value$1);
			return value$1;
		});
		if (obj === null) {
			if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, "key", format) : prefix;
			obj = "";
		}
		if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
			if (encoder) return [formatter(encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format)) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format))];
			return [formatter(prefix) + "=" + formatter(String(obj))];
		}
		var values = [];
		if (typeof obj === "undefined") return values;
		var objKeys;
		if (generateArrayPrefix === "comma" && isArray$1(obj)) {
			if (encodeValuesOnly && encoder) obj = utils$1.maybeMap(obj, encoder);
			objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
		} else if (isArray$1(filter)) objKeys = filter;
		else {
			var keys = Object.keys(obj);
			objKeys = sort ? keys.sort(sort) : keys;
		}
		var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
		var adjustedPrefix = commaRoundTrip && isArray$1(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
		if (allowEmptyArrays && isArray$1(obj) && obj.length === 0) return adjustedPrefix + "[]";
		for (var j$1 = 0; j$1 < objKeys.length; ++j$1) {
			var key = objKeys[j$1];
			var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
			if (skipNulls && value === null) continue;
			var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
			var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
			sideChannel.set(object, step);
			var valueSideChannel = getSideChannel();
			valueSideChannel.set(sentinel, sideChannel);
			pushToArray(values, stringify$3(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray$1(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
		}
		return values;
	};
	var normalizeStringifyOptions = function normalizeStringifyOptions$1(opts) {
		if (!opts) return defaults$1;
		if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
		if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
		if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") throw new TypeError("Encoder has to be a function.");
		var charset = opts.charset || defaults$1.charset;
		if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
		var format = formats$1["default"];
		if (typeof opts.format !== "undefined") {
			if (!has$1.call(formats$1.formatters, opts.format)) throw new TypeError("Unknown format option provided.");
			format = opts.format;
		}
		var formatter = formats$1.formatters[format];
		var filter = defaults$1.filter;
		if (typeof opts.filter === "function" || isArray$1(opts.filter)) filter = opts.filter;
		var arrayFormat;
		if (opts.arrayFormat in arrayPrefixGenerators) arrayFormat = opts.arrayFormat;
		else if ("indices" in opts) arrayFormat = opts.indices ? "indices" : "repeat";
		else arrayFormat = defaults$1.arrayFormat;
		if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
		var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults$1.allowDots : !!opts.allowDots;
		return {
			addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
			allowDots,
			allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$1.allowEmptyArrays,
			arrayFormat,
			charset,
			charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
			commaRoundTrip: !!opts.commaRoundTrip,
			delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
			encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
			encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults$1.encodeDotInKeys,
			encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
			encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
			filter,
			format,
			formatter,
			serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
			skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
			sort: typeof opts.sort === "function" ? opts.sort : null,
			strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
		};
	};
	module.exports = function(object, opts) {
		var obj = object;
		var options = normalizeStringifyOptions(opts);
		var objKeys;
		var filter;
		if (typeof options.filter === "function") {
			filter = options.filter;
			obj = filter("", obj);
		} else if (isArray$1(options.filter)) {
			filter = options.filter;
			objKeys = filter;
		}
		var keys = [];
		if (typeof obj !== "object" || obj === null) return "";
		var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
		var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
		if (!objKeys) objKeys = Object.keys(obj);
		if (options.sort) objKeys.sort(options.sort);
		var sideChannel = getSideChannel();
		for (var i = 0; i < objKeys.length; ++i) {
			var key = objKeys[i];
			var value = obj[key];
			if (options.skipNulls && value === null) continue;
			pushToArray(keys, stringify$2(value, key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
		}
		var joined = keys.join(options.delimiter);
		var prefix = options.addQueryPrefix === true ? "?" : "";
		if (options.charsetSentinel) if (options.charset === "iso-8859-1") prefix += "utf8=%26%2310003%3B&";
		else prefix += "utf8=%E2%9C%93&";
		return joined.length > 0 ? prefix + joined : "";
	};
}) });

//#endregion
//#region node_modules/qs/lib/parse.js
var require_parse = /* @__PURE__ */ __commonJS({ "node_modules/qs/lib/parse.js": ((exports, module) => {
	var utils = require_utils();
	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;
	var defaults = {
		allowDots: false,
		allowEmptyArrays: false,
		allowPrototypes: false,
		allowSparse: false,
		arrayLimit: 20,
		charset: "utf-8",
		charsetSentinel: false,
		comma: false,
		decodeDotInKeys: false,
		decoder: utils.decode,
		delimiter: "&",
		depth: 5,
		duplicates: "combine",
		ignoreQueryPrefix: false,
		interpretNumericEntities: false,
		parameterLimit: 1e3,
		parseArrays: true,
		plainObjects: false,
		strictDepth: false,
		strictNullHandling: false,
		throwOnLimitExceeded: false
	};
	var interpretNumericEntities = function(str) {
		return str.replace(/&#(\d+);/g, function($0, numberStr) {
			return String.fromCharCode(parseInt(numberStr, 10));
		});
	};
	var parseArrayValue = function(val, options, currentArrayLength) {
		if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) return val.split(",");
		if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
		return val;
	};
	var isoSentinel = "utf8=%26%2310003%3B";
	var charsetSentinel = "utf8=%E2%9C%93";
	var parseValues = function parseQueryStringValues(str, options) {
		var obj = { __proto__: null };
		var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
		cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
		var limit$1 = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
		var parts = cleanStr.split(options.delimiter, options.throwOnLimitExceeded ? limit$1 + 1 : limit$1);
		if (options.throwOnLimitExceeded && parts.length > limit$1) throw new RangeError("Parameter limit exceeded. Only " + limit$1 + " parameter" + (limit$1 === 1 ? "" : "s") + " allowed.");
		var skipIndex = -1;
		var i;
		var charset = options.charset;
		if (options.charsetSentinel) {
			for (i = 0; i < parts.length; ++i) if (parts[i].indexOf("utf8=") === 0) {
				if (parts[i] === charsetSentinel) charset = "utf-8";
				else if (parts[i] === isoSentinel) charset = "iso-8859-1";
				skipIndex = i;
				i = parts.length;
			}
		}
		for (i = 0; i < parts.length; ++i) {
			if (i === skipIndex) continue;
			var part = parts[i];
			var bracketEqualsPos = part.indexOf("]=");
			var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
			var key;
			var val;
			if (pos === -1) {
				key = options.decoder(part, defaults.decoder, charset, "key");
				val = options.strictNullHandling ? null : "";
			} else {
				key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
				if (key !== null) val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options, isArray(obj[key]) ? obj[key].length : 0), function(encodedVal) {
					return options.decoder(encodedVal, defaults.decoder, charset, "value");
				});
			}
			if (val && options.interpretNumericEntities && charset === "iso-8859-1") val = interpretNumericEntities(String(val));
			if (part.indexOf("[]=") > -1) val = isArray(val) ? [val] : val;
			if (key !== null) {
				var existing = has.call(obj, key);
				if (existing && options.duplicates === "combine") obj[key] = utils.combine(obj[key], val, options.arrayLimit, options.plainObjects);
				else if (!existing || options.duplicates === "last") obj[key] = val;
			}
		}
		return obj;
	};
	var parseObject = function(chain, val, options, valuesParsed) {
		var currentArrayLength = 0;
		if (chain.length > 0 && chain[chain.length - 1] === "[]") {
			var parentKey = chain.slice(0, -1).join("");
			currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
		}
		var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
		for (var i = chain.length - 1; i >= 0; --i) {
			var obj;
			var root$1 = chain[i];
			if (root$1 === "[]" && options.parseArrays) if (utils.isOverflow(leaf)) obj = leaf;
			else obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf, options.arrayLimit, options.plainObjects);
			else {
				obj = options.plainObjects ? { __proto__: null } : {};
				var cleanRoot = root$1.charAt(0) === "[" && root$1.charAt(root$1.length - 1) === "]" ? root$1.slice(1, -1) : root$1;
				var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
				var index$1 = parseInt(decodedRoot, 10);
				if (!options.parseArrays && decodedRoot === "") obj = { 0: leaf };
				else if (!isNaN(index$1) && root$1 !== decodedRoot && String(index$1) === decodedRoot && index$1 >= 0 && options.parseArrays && index$1 <= options.arrayLimit) {
					obj = [];
					obj[index$1] = leaf;
				} else if (decodedRoot !== "__proto__") obj[decodedRoot] = leaf;
			}
			leaf = obj;
		}
		return leaf;
	};
	var splitKeyIntoSegments = function splitKeyIntoSegments$1(givenKey, options) {
		var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
		if (options.depth <= 0) {
			if (!options.plainObjects && has.call(Object.prototype, key)) {
				if (!options.allowPrototypes) return;
			}
			return [key];
		}
		var brackets = /(\[[^[\]]*])/;
		var child = /(\[[^[\]]*])/g;
		var segment = brackets.exec(key);
		var parent = segment ? key.slice(0, segment.index) : key;
		var keys = [];
		if (parent) {
			if (!options.plainObjects && has.call(Object.prototype, parent)) {
				if (!options.allowPrototypes) return;
			}
			keys.push(parent);
		}
		var i = 0;
		while ((segment = child.exec(key)) !== null && i < options.depth) {
			i += 1;
			var segmentContent = segment[1].slice(1, -1);
			if (!options.plainObjects && has.call(Object.prototype, segmentContent)) {
				if (!options.allowPrototypes) return;
			}
			keys.push(segment[1]);
		}
		if (segment) {
			if (options.strictDepth === true) throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
			keys.push("[" + key.slice(segment.index) + "]");
		}
		return keys;
	};
	var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
		if (!givenKey) return;
		var keys = splitKeyIntoSegments(givenKey, options);
		if (!keys) return;
		return parseObject(keys, val, options, valuesParsed);
	};
	var normalizeParseOptions = function normalizeParseOptions$1(opts) {
		if (!opts) return defaults;
		if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
		if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
		if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") throw new TypeError("Decoder has to be a function.");
		if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
		if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
		var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
		var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
		if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
		return {
			allowDots: typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots,
			allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
			allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
			allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
			arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
			charset,
			charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
			comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
			decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
			decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
			delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
			depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
			duplicates,
			ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
			interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
			parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
			parseArrays: opts.parseArrays !== false,
			plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
			strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
			strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
			throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
		};
	};
	module.exports = function(str, opts) {
		var options = normalizeParseOptions(opts);
		if (str === "" || str === null || typeof str === "undefined") return options.plainObjects ? { __proto__: null } : {};
		var tempObj = typeof str === "string" ? parseValues(str, options) : str;
		var obj = options.plainObjects ? { __proto__: null } : {};
		var keys = Object.keys(tempObj);
		for (var i = 0; i < keys.length; ++i) {
			var key = keys[i];
			var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
			obj = utils.merge(obj, newObj, options);
		}
		if (options.allowSparse === true) return obj;
		return utils.compact(obj);
	};
}) });

//#endregion
//#region node_modules/qs/lib/index.js
var require_lib = /* @__PURE__ */ __commonJS({ "node_modules/qs/lib/index.js": ((exports, module) => {
	var stringify$1 = require_stringify$1();
	var parse = require_parse();
	var formats = require_formats();
	module.exports = {
		formats,
		parse,
		stringify: stringify$1
	};
}) });

//#endregion
//#region node_modules/contentful-sdk-core/dist/create-default-options.js
var import_lib = /* @__PURE__ */ __toESM(require_lib(), 1);
var HOST_REGEX = /^(?!\w+:\/\/)([^\s:]+\.?[^\s:]+)(?::(\d+))?(?!:)$/;
/**
* Create default options
* @private
* @param {CreateHttpClientParams} options - Initialization parameters for the HTTP client
* @return {DefaultOptions} options to pass to axios
*/
function createDefaultOptions(options) {
	const config = {
		insecure: false,
		retryOnError: true,
		logHandler: (level, data) => {
			if (level === "error" && data) {
				const title = [data.name, data.message].filter((a) => a).join(" - ");
				console.error(`[error] ${title}`);
				console.error(data);
				return;
			}
			console.log(`[${level}] ${data}`);
		},
		headers: {},
		httpAgent: false,
		httpsAgent: false,
		timeout: 3e4,
		throttle: 0,
		basePath: "",
		adapter: void 0,
		maxContentLength: 1073741824,
		maxBodyLength: 1073741824,
		...options
	};
	if (!config.accessToken) {
		const missingAccessTokenError = /* @__PURE__ */ new TypeError("Expected parameter accessToken");
		config.logHandler("error", missingAccessTokenError);
		throw missingAccessTokenError;
	}
	const protocol = config.insecure ? "http" : "https";
	const space = config.space ? `${config.space}/` : "";
	let hostname = config.defaultHostname;
	let port = config.insecure ? 80 : 443;
	if (config.host && HOST_REGEX.test(config.host)) {
		const parsed = config.host.split(":");
		if (parsed.length === 2) [hostname, port] = parsed;
		else hostname = parsed[0];
	}
	if (config.basePath) config.basePath = `/${config.basePath.split("/").filter(Boolean).join("/")}`;
	const baseURL = options.baseURL || `${protocol}://${hostname}:${port}${config.basePath}/spaces/${space}`;
	if (!config.headers.Authorization && typeof config.accessToken !== "function") config.headers.Authorization = "Bearer " + config.accessToken;
	return {
		baseURL,
		headers: config.headers,
		httpAgent: config.httpAgent,
		httpsAgent: config.httpsAgent,
		proxy: config.proxy,
		timeout: config.timeout,
		adapter: config.adapter,
		maxContentLength: config.maxContentLength,
		maxBodyLength: config.maxBodyLength,
		paramsSerializer: { serialize: (params) => {
			return import_lib.default.stringify(params);
		} },
		logHandler: config.logHandler,
		responseLogger: config.responseLogger,
		requestLogger: config.requestLogger,
		retryOnError: config.retryOnError
	};
}

//#endregion
//#region node_modules/contentful-sdk-core/dist/create-http-client.js
function copyHttpClientParams(options) {
	const copiedOptions = index(options);
	copiedOptions.httpAgent = options.httpAgent;
	copiedOptions.httpsAgent = options.httpsAgent;
	return copiedOptions;
}
/**
* Create pre-configured axios instance
* @private
* @param {AxiosStatic} axios - Axios library
* @param {CreateHttpClientParams} options - Initialization parameters for the HTTP client
* @return {AxiosInstance} Initialized axios instance
*/
function createHttpClient(axios$1, options) {
	const axiosOptions = createDefaultOptions(options);
	const instance = axios$1.create(axiosOptions);
	instance.httpClientParams = options;
	/**
	* Creates a new axios instance with the same default base parameters as the
	* current one, and with any overrides passed to the newParams object
	* This is useful as the SDKs use dependency injection to get the axios library
	* and the version of the library comes from different places depending
	* on whether it's a browser build or a node.js build.
	* @private
	* @param {CreateHttpClientParams} newParams - Initialization parameters for the HTTP client
	* @return {AxiosInstance} Initialized axios instance
	*/
	instance.cloneWithNewParams = function(newParams) {
		return createHttpClient(axios$1, {
			...copyHttpClientParams(options),
			...newParams
		});
	};
	/**
	* Apply interceptors.
	* Please note that the order of interceptors is important
	*/
	if (options.onBeforeRequest) instance.interceptors.request.use(options.onBeforeRequest);
	if (typeof options.accessToken === "function") asyncToken(instance, options.accessToken);
	if (options.throttle) rateLimitThrottle(instance, options.throttle);
	rateLimit(instance, options.retryLimit);
	if (options.onError) instance.interceptors.response.use((response) => response, options.onError);
	return instance;
}

//#endregion
//#region node_modules/contentful-sdk-core/dist/create-request-config.js
/**
* Creates request parameters configuration by parsing an existing query object
* @private
* @param {Object} query
* @return {Object} Config object with `params` property, ready to be used in axios
*/
function createRequestConfig({ query }) {
	const config = {};
	delete query.resolveLinks;
	config.params = index(query);
	return config;
}

//#endregion
//#region node_modules/contentful-sdk-core/dist/freeze-sys.js
function deepFreeze(object) {
	const propNames = Object.getOwnPropertyNames(object);
	for (const name of propNames) {
		const value = object[name];
		if (value && typeof value === "object") deepFreeze(value);
	}
	return Object.freeze(object);
}
function freezeSys(obj) {
	deepFreeze(obj.sys || {});
	return obj;
}

//#endregion
//#region node_modules/contentful-sdk-core/dist/get-user-agent.js
var import_browser = /* @__PURE__ */ __toESM(require_browser(), 1);
function getBrowserOS() {
	const win = getWindow();
	if (!win) return null;
	const userAgent = win.navigator.userAgent;
	const platform = win.navigator.platform;
	const macosPlatforms = [
		"Macintosh",
		"MacIntel",
		"MacPPC",
		"Mac68K"
	];
	const windowsPlatforms = [
		"Win32",
		"Win64",
		"Windows",
		"WinCE"
	];
	const iosPlatforms = [
		"iPhone",
		"iPad",
		"iPod"
	];
	if (macosPlatforms.indexOf(platform) !== -1) return "macOS";
	else if (iosPlatforms.indexOf(platform) !== -1) return "iOS";
	else if (windowsPlatforms.indexOf(platform) !== -1) return "Windows";
	else if (/Android/.test(userAgent)) return "Android";
	else if (/Linux/.test(platform)) return "Linux";
	return null;
}
function getNodeOS() {
	const platform = import_browser.default.platform || "linux";
	const version = import_browser.default.version || "0.0.0";
	const platformMap = {
		android: "Android",
		aix: "Linux",
		darwin: "macOS",
		freebsd: "Linux",
		linux: "Linux",
		openbsd: "Linux",
		sunos: "Linux",
		win32: "Windows"
	};
	if (platform in platformMap) return `${platformMap[platform] || "Linux"}/${version}`;
	return null;
}
function getUserAgentHeader(sdk, application, integration, feature) {
	const headerParts = [];
	if (application) headerParts.push(`app ${application}`);
	if (integration) headerParts.push(`integration ${integration}`);
	if (feature) headerParts.push("feature " + feature);
	headerParts.push(`sdk ${sdk}`);
	let platform = null;
	try {
		if (isReactNative()) {
			platform = getBrowserOS();
			headerParts.push("platform ReactNative");
		} else if (isNode()) {
			platform = getNodeOS();
			headerParts.push(`platform node.js/${getNodeVersion()}`);
		} else {
			platform = getBrowserOS();
			headerParts.push("platform browser");
		}
	} catch (e) {
		platform = null;
	}
	if (platform) headerParts.push(`os ${platform}`);
	return `${headerParts.filter((item) => item !== "").join("; ")};`;
}

//#endregion
//#region node_modules/contentful-sdk-core/dist/to-plain-object.js
/**
* Mixes in a method to return just a plain object with no additional methods
* @private
* @param data - Any plain JSON response returned from the API
* @return Enhanced object with toPlainObject method
*/
function toPlainObject(data) {
	return Object.defineProperty(data, "toPlainObject", {
		enumerable: false,
		configurable: false,
		writable: false,
		value: function() {
			return index(this);
		}
	});
}

//#endregion
//#region node_modules/lodash/_overArg.js
var require__overArg = /* @__PURE__ */ __commonJS({ "node_modules/lodash/_overArg.js": ((exports, module) => {
	/**
	* Creates a unary function that invokes `func` with its argument transformed.
	*
	* @private
	* @param {Function} func The function to wrap.
	* @param {Function} transform The argument transform.
	* @returns {Function} Returns the new function.
	*/
	function overArg(func, transform) {
		return function(arg) {
			return func(transform(arg));
		};
	}
	module.exports = overArg;
}) });

//#endregion
//#region node_modules/lodash/_getPrototype.js
var require__getPrototype = /* @__PURE__ */ __commonJS({ "node_modules/lodash/_getPrototype.js": ((exports, module) => {
	/** Built-in value references. */
	var getPrototype$1 = require__overArg()(Object.getPrototypeOf, Object);
	module.exports = getPrototype$1;
}) });

//#endregion
//#region node_modules/lodash/isPlainObject.js
var require_isPlainObject = /* @__PURE__ */ __commonJS({ "node_modules/lodash/isPlainObject.js": ((exports, module) => {
	var baseGetTag = require__baseGetTag(), getPrototype = require__getPrototype(), isObjectLike = require_isObjectLike();
	/** `Object#toString` result references. */
	var objectTag = "[object Object]";
	/** Used for built-in method references. */
	var funcProto = Function.prototype, objectProto = Object.prototype;
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	/**
	* Checks if `value` is a plain object, that is, an object created by the
	* `Object` constructor or one with a `[[Prototype]]` of `null`.
	*
	* @static
	* @memberOf _
	* @since 0.8.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	* @example
	*
	* function Foo() {
	*   this.a = 1;
	* }
	*
	* _.isPlainObject(new Foo);
	* // => false
	*
	* _.isPlainObject([1, 2, 3]);
	* // => false
	*
	* _.isPlainObject({ 'x': 0, 'y': 0 });
	* // => true
	*
	* _.isPlainObject(Object.create(null));
	* // => true
	*/
	function isPlainObject$1(value) {
		if (!isObjectLike(value) || baseGetTag(value) != objectTag) return false;
		var proto = getPrototype(value);
		if (proto === null) return true;
		var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
		return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}
	module.exports = isPlainObject$1;
}) });

//#endregion
//#region node_modules/contentful-sdk-core/dist/error-handler.js
var import_isPlainObject = /* @__PURE__ */ __toESM(require_isPlainObject(), 1);
function obscureHeaders(config) {
	if (config?.headers?.["Authorization"]) {
		const token = `...${config.headers["Authorization"].toString().substr(-5)}`;
		config.headers["Authorization"] = `Bearer ${token}`;
	}
	if (config?.headers?.["X-Contentful-Resource-Resolution"]) {
		const token = `...${config.headers["X-Contentful-Resource-Resolution"].toString().substr(-5)}`;
		config.headers["X-Contentful-Resource-Resolution"] = token;
	}
}
/**
* Handles errors received from the server. Parses the error into a more useful
* format, places it in an exception and throws it.
* See https://www.contentful.com/developers/docs/references/errors/
* for more details on the data received on the errorResponse.data property
* and the expected error codes.
* @private
*/
function errorHandler(errorResponse) {
	const { config, response } = errorResponse;
	let errorName;
	obscureHeaders(config);
	if (!(0, import_isPlainObject.default)(response) || !(0, import_isPlainObject.default)(config)) throw errorResponse;
	const data = response?.data;
	const errorData = {
		status: response?.status,
		statusText: response?.statusText,
		message: "",
		details: {}
	};
	if (config && (0, import_isPlainObject.default)(config)) errorData.request = {
		url: config.url,
		headers: config.headers,
		method: config.method,
		payloadData: config.data
	};
	if (data && typeof data === "object") {
		if ("requestId" in data) errorData.requestId = data.requestId || "UNKNOWN";
		if ("message" in data) errorData.message = data.message || "";
		if ("details" in data) errorData.details = data.details || {};
		errorName = data.sys?.id;
	}
	const error = /* @__PURE__ */ new Error();
	error.name = errorName && errorName !== "Unknown" ? errorName : `${response?.status} ${response?.statusText}`;
	try {
		error.message = JSON.stringify(errorData, null, "  ");
	} catch {
		error.message = errorData?.message ?? "";
	}
	throw error;
}

//#endregion
//#region node_modules/contentful/dist/esm/create-global-options.js
/**
* @param globalSettings - Global library settings
* @returns getGlobalSettings - Method returning client settings
* @category Client
*/
function createGlobalOptions(globalSettings) {
	/**
	* Method merging pre-configured global options and provided local parameters
	* @param query - regular query object used for collection endpoints
	* @param query.environment - optional name of the environment
	* @param query.space - optional space ID
	* @param query.spaceBaseUrl - optional base URL for the space
	* @param query.environmentBaseUrl - optional base URL for the environment
	* @returns global options
	*/
	return function getGlobalOptions(query) {
		return Object.assign({}, globalSettings, query);
	};
}

//#endregion
//#region node_modules/@contentful/content-source-maps/dist/index.js
var W = {
	0: 8203,
	1: 8204,
	2: 8205,
	3: 8290,
	4: 8291,
	5: 8288,
	6: 65279,
	7: 8289,
	8: 119155,
	9: 119156,
	a: 119157,
	b: 119158,
	c: 119159,
	d: 119160,
	e: 119161,
	f: 119162
}, L = {
	0: 8203,
	1: 8204,
	2: 8205,
	3: 65279
}, j = new Array(4).fill(String.fromCodePoint(L[0])).join(""), V = "\0";
function U(t) {
	let n = JSON.stringify(t);
	return `${j}${Array.from(n).map((o) => {
		let e = o.charCodeAt(0);
		if (e > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${n} on character ${o} (${e})`);
		return Array.from(e.toString(4).padStart(4, "0")).map((r) => String.fromCodePoint(L[r])).join("");
	}).join("")}`;
}
function Z(t) {
	return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\d+(?:[-:\/]\d+){2}(?:T\d+(?:[-:\/]\d+){1,2}(\.\d+)?Z?)?/.test(t) ? !1 : !!Date.parse(t);
}
function q(t) {
	try {
		new URL(t, t.startsWith("/") ? "https://acme.com" : void 0);
	} catch (n) {
		return !1;
	}
	return !0;
}
function G(t, n, o = "auto") {
	return o === !0 || o === "auto" && (Z(t) || q(t)) ? t : `${t}${U(n)}`;
}
var H = Object.fromEntries(Object.entries(L).map((t) => t.reverse())), F = Object.fromEntries(Object.entries(W).map((t) => t.reverse())), K = `${Object.values(W).map((t) => `\\u{${t.toString(16)}}`).join("")}`, O = new RegExp(`[${K}]{4,}`, "gu");
function w(t, n) {
	return G(t, n);
}
var x, k;
function ne() {
	if (k) return x;
	k = 1;
	var t = Object.prototype.hasOwnProperty, n = Object.prototype.toString;
	return x = function(e, r, s) {
		if (n.call(r) !== "[object Function]") throw new TypeError("iterator must be a function");
		var c = e.length;
		if (c === +c) for (var i = 0; i < c; i++) r.call(s, e[i], i, e);
		else for (var u in e) t.call(e, u) && r.call(s, e[u], u, e);
	}, x;
}
var I, _;
function re() {
	if (_) return I;
	_ = 1;
	var t = ne();
	I = n;
	function n(o, e, r) {
		if (arguments.length === 3) return n.set(o, e, r);
		if (arguments.length === 2) return n.get(o, e);
		var s = n.bind(n, o);
		for (var c in n) n.hasOwnProperty(c) && (s[c] = n[c].bind(s, o));
		return s;
	}
	return n.get = function(e, r) {
		for (var s = Array.isArray(r) ? r : n.parse(r), c = 0; c < s.length; ++c) {
			var i = s[c];
			if (!(typeof e == "object" && i in e)) throw new Error("Invalid reference token: " + i);
			e = e[i];
		}
		return e;
	}, n.set = function(e, r, s) {
		var c = Array.isArray(r) ? r : n.parse(r), i = c[0];
		if (c.length === 0) throw Error("Can not set the root object");
		for (var u = 0; u < c.length - 1; ++u) {
			var a = c[u];
			typeof a != "string" && typeof a != "number" && (a = String(a)), !(a === "__proto__" || a === "constructor" || a === "prototype") && (a === "-" && Array.isArray(e) && (a = e.length), i = c[u + 1], a in e || (i.match(/^(\d+|-)$/) ? e[a] = [] : e[a] = {}), e = e[a]);
		}
		return i === "-" && Array.isArray(e) && (i = e.length), e[i] = s, this;
	}, n.remove = function(o, e) {
		var r = Array.isArray(e) ? e : n.parse(e), s = r[r.length - 1];
		if (s === void 0) throw new Error("Invalid JSON pointer for remove: \"" + e + "\"");
		var c = n.get(o, r.slice(0, -1));
		if (Array.isArray(c)) {
			var i = +s;
			if (s === "" && isNaN(i)) throw new Error("Invalid array index: \"" + s + "\"");
			Array.prototype.splice.call(c, i, 1);
		} else delete c[s];
	}, n.dict = function(e, r) {
		var s = {};
		return n.walk(e, function(c, i) {
			s[i] = c;
		}, r), s;
	}, n.walk = function(e, r, s) {
		var c = [];
		s = s || function(i) {
			var u = Object.prototype.toString.call(i);
			return u === "[object Object]" || u === "[object Array]";
		}, function i(u) {
			t(u, function(a, l) {
				c.push(String(l)), s(a) ? i(a) : r(a, n.compile(c)), c.pop();
			});
		}(e);
	}, n.has = function(e, r) {
		try {
			n.get(e, r);
		} catch (s) {
			return !1;
		}
		return !0;
	}, n.escape = function(e) {
		return e.toString().replace(/~/g, "~0").replace(/\//g, "~1");
	}, n.unescape = function(e) {
		return e.replace(/~1/g, "/").replace(/~0/g, "~");
	}, n.parse = function(e) {
		if (e === "") return [];
		if (e.charAt(0) !== "/") throw new Error("Invalid JSON pointer: " + e);
		return e.substring(1).split(/\//).map(n.unescape);
	}, n.compile = function(e) {
		return e.length === 0 ? "" : "/" + e.map(n.escape).join("/");
	}, I;
}
var p = re();
var oe = ({ pointer: t, mappings: n, data: o, hiddenStrings: e }) => {
	const r = n[t];
	if (r) {
		delete n[t];
		const s = b(o, t);
		for (const c of s) {
			n[c] = r;
			const u = w(p.get(o, c), e);
			p.set(o, c, u);
		}
	} else {
		const s = b(o, t);
		for (const c of s) {
			const u = w(p.get(o, c), e);
			p.set(o, c, u);
		}
	}
};
function se(t) {
	return "content" in t && !!t.content;
}
var b = (t, n = "") => {
	const o = [], e = p.get(t, n);
	if (se(e)) for (let r = 0; r < e.content.length; r++) e.content[r].nodeType === "text" ? o.push(`${n}/content/${r}/value`) : o.push(...b(t, `${n}/content/${r}`));
	return o;
}, C = ({ entityId: t, entityType: n, space: o, environment: e, field: r, locale: s, editorInterface: c, fieldType: i, targetOrigin: u, platform: a }) => {
	const d = {
		origin: "contentful.com",
		href: `${`${u || "https://app.contentful.com"}/spaces/${o}/environments/${e}`}/${n === "Entry" ? "entries" : "assets"}/${t}/?focusedField=${r}&focusedLocale=${s}&source=vercel-content-link`,
		contentful: {
			editorInterface: c,
			fieldType: i
		}
	};
	return a === "vercel" && delete d.contentful, d;
}, B = (t) => [
	"builtin",
	"sidebar-builtin",
	"editor-builtin"
].includes(t), D = (t) => ce.includes(t);
function Q(t) {
	if (typeof structuredClone == "function") return structuredClone(t);
	try {
		return JSON.parse(JSON.stringify(t));
	} catch (n) {
		return console.warn("Failed to clone data:", t, n), t;
	}
}
var ce = [
	"singleLine",
	"tagEditor",
	"listInput",
	"checkbox",
	"richTextEditor",
	"multipleLine"
];
function P(t, n, o, e, r, s, c) {
	const i = c ? n[c] : n;
	switch (t) {
		case "Symbol": {
			const u = w(i, o);
			p.set(e, r, u);
			break;
		}
		case "Text": {
			const u = w(i, o);
			p.set(e, r, u);
			break;
		}
		case "RichText":
			oe({
				pointer: "",
				mappings: s,
				data: i,
				hiddenStrings: o
			});
			break;
		case "Array": {
			const u = i.map((a) => typeof a == "string" ? w(a, o) : a);
			p.set(e, r, u);
			break;
		}
	}
}
var fe = (t, n, o) => {
	if (!t || !t.extensions || !t.extensions.contentSourceMaps) return console.error("GraphQL response does not contain Content Source Maps information.", t), t;
	const e = Q(t), { spaces: r, environments: s, editorInterfaces: c, fields: i, locales: u, entries: a, assets: l, mappings: m, fieldTypes: v } = e.extensions.contentSourceMaps, y = e;
	for (const d in m) {
		const { source: f } = m[d], h = "entry" in f ? a[f.entry] : l[f.asset], M = "entry" in f ? "Entry" : "Asset";
		if (!h) return e;
		const g = r[h.space], A = s[h.environment], E = h.id, S = i[f.field], T = u[f.locale], N = c[f.editorInterface], J = v[f.fieldType];
		if (!(B(N.widgetNamespace) && !D(N.widgetId)) && p.has(y, d)) {
			const R = p.get(y, d);
			if (R !== null) P(J, R, C({
				entityId: E,
				entityType: M,
				space: g,
				environment: A,
				field: S,
				locale: T,
				editorInterface: N,
				fieldType: J,
				targetOrigin: n,
				platform: o
			}), y, d, m);
		}
	}
	return e;
}, $ = (t, n, o, e, r) => {
	if (!t.fields) return;
	const { contentSourceMaps: s } = t.sys;
	if (!s) return;
	const { mappings: c } = s;
	for (const i in c) {
		const { source: u } = c[i], a = t.sys.space.sys.id, l = t.sys.environment.sys.id, m = t.sys.id, v = t.sys.type, y = n[u.fieldType], d = o[u.editorInterface];
		if (B(d.widgetNamespace) && !D(d.widgetId)) continue;
		const f = i.startsWith("/") ? i : `/${i}`;
		if (p.has(t, f)) {
			const h = p.get(t, f);
			if (h === null) return;
			const g = f.split("/").pop();
			if (!g) {
				console.error("Field name could not be extracted from the pointer", f);
				return;
			}
			const A = t.sys.locale;
			if (A) P(y, h, C({
				entityId: m,
				entityType: v,
				space: a,
				environment: l,
				field: g,
				locale: A,
				editorInterface: d,
				fieldType: y,
				targetOrigin: e,
				platform: r
			}), t, f, c);
			else Object.keys(h).forEach((S) => {
				P(y, h, C({
					entityId: m,
					entityType: v,
					space: a,
					environment: l,
					field: g,
					locale: S,
					editorInterface: d,
					fieldType: y,
					targetOrigin: e,
					platform: r
				}), t, `${f}/${S}`, c, S);
			});
		}
	}
}, le = (t, n, o) => {
	var r;
	const e = Q(t);
	if (e.sys && "items" in e) {
		const s = e;
		if (!((r = s.sys) != null && r.contentSourceMapsLookup)) return s;
		const { contentSourceMapsLookup: { fieldTypes: c, editorInterfaces: i } } = s.sys, { items: u, includes: a } = s;
		u.forEach((l) => $(l, c, i, n, o)), a && a.Entry && a.Entry.forEach((l) => $(l, c, i, n, o)), a && a.Asset && a.Asset.forEach((l) => $(l, c, i, n, o));
	} else {
		const s = e;
		if (!s.sys.contentSourceMapsLookup) return console.error("Content source maps lookup data is missing"), s;
		$(s, s.sys.contentSourceMapsLookup.fieldTypes, s.sys.contentSourceMapsLookup.editorInterfaces, n, o);
	}
	return e;
};

//#endregion
//#region node_modules/contentful-resolve-response/dist/esm/index.js
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
	return typeof obj;
} : function(obj) {
	return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var _slicedToArray = function() {
	function sliceIterator(arr, i) {
		var _arr = [];
		var _n = true;
		var _d = false;
		var _e = void 0;
		try {
			for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
				_arr.push(_s.value);
				if (i && _arr.length === i) break;
			}
		} catch (err) {
			_d = true;
			_e = err;
		} finally {
			try {
				if (!_n && _i["return"]) _i["return"]();
			} finally {
				if (_d) throw _e;
			}
		}
		return _arr;
	}
	return function(arr, i) {
		if (Array.isArray(arr)) return arr;
		else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
		else throw new TypeError("Invalid attempt to destructure non-iterable instance");
	};
}();
function _toConsumableArray(arr) {
	if (Array.isArray(arr)) {
		for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
		return arr2;
	} else return Array.from(arr);
}
var UNRESOLVED_LINK = {};
/**
* isLink Function
* Checks if the object has sys.type "Link"
* @param object
*/
var isLink = function isLink$1(object) {
	return object && object.sys && object.sys.type === "Link";
};
/**
* isResourceLink Function
* Checks if the object has sys.type "ResourceLink"
* @param object
*/
var isResourceLink = function isResourceLink$1(object) {
	return object && object.sys && object.sys.type === "ResourceLink";
};
/**
* Creates a key with spaceId and a key without for entityMap
*
* @param {*} sys
* @param {String} sys.type
* @param {String} sys.id
* @param {*} sys.space
* @param {*} sys.space.sys
* @param {String} sys.space.id
* @return {string[]}
*/
var makeEntityMapKeys = function makeEntityMapKeys$1(sys) {
	if (sys.space && sys.environment) return [sys.type + "!" + sys.id, sys.space.sys.id + "!" + sys.environment.sys.id + "!" + sys.type + "!" + sys.id];
	return [sys.type + "!" + sys.id];
};
/**
* Looks up in entityMap
*
* @param entityMap
* @param {*} linkData
* @param {String} linkData.type
* @param {String} linkData.linkType
* @param {String} linkData.id
* @param {String} linkData.urn
* @return {String}
*/
var lookupInEntityMap = function lookupInEntityMap$1(entityMap, linkData) {
	var entryId = linkData.entryId, linkType = linkData.linkType, spaceId = linkData.spaceId, environmentId = linkData.environmentId;
	if (spaceId && environmentId) return entityMap.get(spaceId + "!" + environmentId + "!" + linkType + "!" + entryId);
	return entityMap.get(linkType + "!" + entryId);
};
var getIdsFromUrn = function getIdsFromUrn$1(urn) {
	var regExp = /.*:spaces\/([^/]+)(?:\/environments\/([^/]+))?\/entries\/([^/]+)$/;
	if (!regExp.test(urn)) return;
	var _urn$match2 = _slicedToArray(urn.match(regExp), 4);
	_urn$match2[0];
	var spaceId = _urn$match2[1], _urn$match2$ = _urn$match2[2];
	return {
		spaceId,
		environmentId: _urn$match2$ === void 0 ? "master" : _urn$match2$,
		entryId: _urn$match2[3]
	};
};
/**
* getResolvedLink Function
*
* @param entityMap
* @param link
* @return {undefined}
*/
var getResolvedLink = function getResolvedLink$1(entityMap, link) {
	var _link$sys = link.sys, type = _link$sys.type, linkType = _link$sys.linkType;
	if (type === "ResourceLink") {
		if (!linkType.startsWith("Contentful:")) return link;
		var urn = link.sys.urn;
		var _getIdsFromUrn = getIdsFromUrn(urn), spaceId = _getIdsFromUrn.spaceId, environmentId = _getIdsFromUrn.environmentId, _entryId = _getIdsFromUrn.entryId;
		var extractedLinkType = linkType.split(":")[1];
		return lookupInEntityMap(entityMap, {
			linkType: extractedLinkType,
			entryId: _entryId,
			spaceId,
			environmentId
		}) || UNRESOLVED_LINK;
	}
	var entryId = link.sys.id;
	return lookupInEntityMap(entityMap, {
		linkType,
		entryId
	}) || UNRESOLVED_LINK;
};
/**
* cleanUpLinks Function
* - Removes unresolvable links from Arrays and Objects
*
* @param {Object[]|Object} input
*/
var cleanUpLinks = function cleanUpLinks$1(input) {
	if (Array.isArray(input)) return input.filter(function(val) {
		return val !== UNRESOLVED_LINK;
	});
	for (var key in input) if (input[key] === UNRESOLVED_LINK) delete input[key];
	return input;
};
/**
* walkMutate Function
* @param input
* @param predicate
* @param mutator
* @param removeUnresolved
* @return {*}
*/
var walkMutate = function walkMutate$1(input, predicate, mutator, removeUnresolved) {
	if (predicate(input)) return mutator(input);
	if (input && (typeof input === "undefined" ? "undefined" : _typeof(input)) === "object") {
		for (var key in input) if (input.hasOwnProperty(key)) input[key] = walkMutate$1(input[key], predicate, mutator, removeUnresolved);
		if (removeUnresolved) input = cleanUpLinks(input);
	}
	return input;
};
var normalizeLink = function normalizeLink$1(entityMap, link, removeUnresolved) {
	var resolvedLink = getResolvedLink(entityMap, link);
	if (resolvedLink === UNRESOLVED_LINK) return removeUnresolved ? resolvedLink : link;
	return resolvedLink;
};
var makeEntryObject = function makeEntryObject$1(item, itemEntryPoints) {
	if (!Array.isArray(itemEntryPoints)) return item;
	return Object.keys(item).filter(function(ownKey) {
		return itemEntryPoints.indexOf(ownKey) !== -1;
	}).reduce(function(entryObj, entryPoint) {
		entryObj[entryPoint] = item[entryPoint];
		return entryObj;
	}, {});
};
/**
* resolveResponse Function
* Resolves contentful response to normalized form.
* @param {Object} response Contentful response
* @param {{removeUnresolved: Boolean, itemEntryPoints: Array<String>}|{}} options
* @param {Boolean} options.removeUnresolved - Remove unresolved links default:false
* @param {Array<String>} options.itemEntryPoints - Resolve links only in those item properties
* @return {Object}
*/
var resolveResponse = function resolveResponse$1(response, options) {
	options = options || {};
	if (!response.items) return [];
	var responseClone = index(response);
	var allIncludes = Object.keys(responseClone.includes || {}).reduce(function(all$1, type) {
		return [].concat(_toConsumableArray(all$1), _toConsumableArray(response.includes[type]));
	}, []);
	var allEntries = [].concat(_toConsumableArray(responseClone.items), _toConsumableArray(allIncludes)).filter(function(entity) {
		return Boolean(entity.sys);
	});
	var entityMap = new Map(allEntries.reduce(function(acc, entity) {
		var entries = makeEntityMapKeys(entity.sys).map(function(key) {
			return [key, entity];
		});
		acc.push.apply(acc, _toConsumableArray(entries));
		return acc;
	}, []));
	allEntries.forEach(function(item) {
		var entryObject = makeEntryObject(item, options.itemEntryPoints);
		Object.assign(item, walkMutate(entryObject, function(x$1) {
			return isLink(x$1) || isResourceLink(x$1);
		}, function(link) {
			return normalizeLink(entityMap, link, options.removeUnresolved);
		}, options.removeUnresolved));
	});
	return responseClone.items;
};
var esm_default = resolveResponse;

//#endregion
//#region node_modules/json-stringify-safe/stringify.js
var require_stringify = /* @__PURE__ */ __commonJS({ "node_modules/json-stringify-safe/stringify.js": ((exports, module) => {
	exports = module.exports = stringify;
	exports.getSerialize = serializer;
	function stringify(obj, replacer, spaces, cycleReplacer) {
		return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
	}
	function serializer(replacer, cycleReplacer) {
		var stack = [], keys = [];
		if (cycleReplacer == null) cycleReplacer = function(key, value) {
			if (stack[0] === value) return "[Circular ~]";
			return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
		};
		return function(key, value) {
			if (stack.length > 0) {
				var thisPos = stack.indexOf(this);
				~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
				~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
				if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value);
			} else stack.push(value);
			return replacer == null ? value : replacer.call(this, key, value);
		};
	}
}) });

//#endregion
//#region node_modules/contentful/dist/esm/mixins/stringify-safe.js
var import_stringify$1 = /* @__PURE__ */ __toESM(require_stringify(), 1);
function mixinStringifySafe(data) {
	return Object.defineProperty(data, "stringifySafe", {
		enumerable: false,
		configurable: false,
		writable: false,
		value: function(serializer$1 = null, indent = "") {
			return (0, import_stringify$1.default)(this, serializer$1, indent, (key, value) => {
				return { sys: {
					type: "Link",
					linkType: "Entry",
					id: value.sys.id,
					circular: true
				} };
			});
		}
	});
}

//#endregion
//#region node_modules/contentful/dist/esm/paged-sync.js
/**
* Retrieves all the available pages for a sync operation
*/
async function pagedSync(http, query, options) {
	if (!query || !query.initial && !query.nextSyncToken && !query.nextPageToken) throw new Error("Please provide one of `initial`, `nextSyncToken` or `nextPageToken` parameters for syncing");
	if (query["content_type"] && !query.type) query.type = "Entry";
	else if (query["content_type"] && query.type && query.type !== "Entry") throw new Error("When using the `content_type` filter your `type` parameter cannot be different from `Entry`.");
	const { withoutLinkResolution, withoutUnresolvableLinks, paginate } = Object.assign(Object.assign({}, {
		withoutLinkResolution: false,
		withoutUnresolvableLinks: false,
		paginate: true
	}), options);
	const response = await getSyncPage(http, [], query, { paginate });
	if (!withoutLinkResolution) response.items = esm_default(response, {
		removeUnresolved: withoutUnresolvableLinks,
		itemEntryPoints: ["fields"]
	});
	const mappedResponseItems = mapResponseItems(response.items);
	if (response.nextSyncToken) mappedResponseItems.nextSyncToken = response.nextSyncToken;
	if (response.nextPageToken) mappedResponseItems.nextPageToken = response.nextPageToken;
	return freezeSys(mixinStringifySafe(toPlainObject(mappedResponseItems)));
}
/**
* @private
* @param items
* @returns Entities mapped to an object for each entity type
*/
function mapResponseItems(items) {
	const reducer = (type) => {
		return (accumulated, item) => {
			if (item.sys.type === type) accumulated.push(toPlainObject(item));
			return accumulated;
		};
	};
	return {
		entries: items.reduce(reducer("Entry"), []),
		assets: items.reduce(reducer("Asset"), []),
		deletedEntries: items.reduce(reducer("DeletedEntry"), []),
		deletedAssets: items.reduce(reducer("DeletedAsset"), [])
	};
}
function createRequestQuery(originalQuery) {
	if (originalQuery.nextPageToken) return { sync_token: originalQuery.nextPageToken };
	if (originalQuery.nextSyncToken) return { sync_token: originalQuery.nextSyncToken };
	if (originalQuery.sync_token) return { sync_token: originalQuery.sync_token };
	return originalQuery;
}
/**
* If the response contains a nextPageUrl, extracts the sync token to get the
* next page and calls itself again with that token.
* Otherwise, if the response contains a nextSyncUrl, extracts the sync token
* and returns it.
* On each call of this function, any retrieved items are collected in the
* supplied items array, which gets returned in the end.
*/
async function getSyncPage(http, items, query, { paginate }) {
	const requestQuery = createRequestQuery(query);
	const data = (await http.get("sync", createRequestConfig({ query: requestQuery }))).data || {};
	items = items.concat(data.items || []);
	if (data.nextPageUrl) {
		if (paginate) {
			delete requestQuery.initial;
			requestQuery.sync_token = getToken(data.nextPageUrl);
			return getSyncPage(http, items, requestQuery, { paginate });
		}
		return {
			items,
			nextPageToken: getToken(data.nextPageUrl)
		};
	} else if (data.nextSyncUrl) return {
		items,
		nextSyncToken: getToken(data.nextSyncUrl)
	};
	else return { items: [] };
}
/**
* Extracts token out of an url
* @private
*/
function getToken(url) {
	const urlParts = url.split("?");
	return urlParts.length > 0 ? urlParts[1].replace("sync_token=", "") : "";
}

//#endregion
//#region node_modules/contentful/dist/esm/utils/normalize-search-parameters.js
function normalizeSearchParameters(query) {
	const convertedQuery = {};
	let hasConverted = false;
	for (const key in query) if (Array.isArray(query[key])) {
		convertedQuery[key] = query[key].join(",");
		hasConverted = true;
	}
	if (hasConverted) return Object.assign(Object.assign({}, query), convertedQuery);
	return query;
}

//#endregion
//#region node_modules/contentful/dist/esm/utils/query-selection-set.js
function getQuerySelectionSet(query) {
	if (!query.select) return /* @__PURE__ */ new Set();
	const allSelects = Array.isArray(query.select) ? query.select : query.select.split(",").map((q$1) => q$1.trim());
	return new Set(allSelects);
}

//#endregion
//#region node_modules/contentful/dist/esm/utils/normalize-select.js
function normalizeSelect(query) {
	if (!query.select) return query;
	const selectedSet = getQuerySelectionSet(query);
	if (selectedSet.has("sys")) return query;
	selectedSet.add("sys.id");
	selectedSet.add("sys.type");
	return Object.assign(Object.assign({}, query), { select: [...selectedSet].join(",") });
}

//#endregion
//#region node_modules/contentful/dist/esm/utils/resolve-circular.js
function resolveCircular(data, { resolveLinks, removeUnresolved }) {
	const wrappedData = mixinStringifySafe(data);
	if (resolveLinks) wrappedData.items = esm_default(wrappedData, {
		removeUnresolved,
		itemEntryPoints: ["fields"]
	});
	return wrappedData;
}

//#endregion
//#region node_modules/contentful/dist/esm/utils/validation-error.js
var ValidationError = class extends Error {
	constructor(name, message) {
		super(`Invalid "${name}" provided, ` + message);
		this.name = "ValidationError";
	}
};

//#endregion
//#region node_modules/contentful/dist/esm/utils/validate-timestamp.js
function validateTimestamp(name, timestamp, options) {
	options = options || {};
	if (typeof timestamp !== "number") throw new ValidationError(name, `only numeric values are allowed for timestamps, provided type was "${typeof timestamp}"`);
	if (options.maximum && timestamp > options.maximum) throw new ValidationError(name, `value (${timestamp}) cannot be further in the future than expected maximum (${options.maximum})`);
	if (options.now && timestamp < options.now) throw new ValidationError(name, `value (${timestamp}) cannot be in the past, current time was ${options.now}`);
}

//#endregion
//#region node_modules/contentful/dist/esm/utils/timeline-preview-helpers.js
function isValidRelease(release) {
	return !!(release && typeof release === "object" && typeof release.lte === "string");
}
function isValidTimestamp(timestamp) {
	return !!(timestamp && typeof timestamp === "object" && (typeof timestamp.lte === "string" || timestamp.lte instanceof Date));
}
var isValidTimelinePreviewConfig = (timelinePreview) => {
	if (typeof timelinePreview !== "object" || timelinePreview === null || Array.isArray(timelinePreview)) throw new ValidationError("timelinePreview", `The 'timelinePreview' parameter must be an object.`);
	const hasRelease = isValidRelease(timelinePreview.release);
	const hasTimestamp = isValidTimestamp(timelinePreview.timestamp);
	if (!hasRelease && !hasTimestamp) throw new ValidationError("timelinePreview", `The 'timelinePreview' object must have at least one of 'release' or 'timestamp' with a valid 'lte' property.`);
	return hasRelease || hasTimestamp;
};
var getTimelinePreviewParams = (params) => {
	var _a$1, _b;
	const host = params === null || params === void 0 ? void 0 : params.host;
	const timelinePreview = (_a$1 = params === null || params === void 0 ? void 0 : params.timelinePreview) !== null && _a$1 !== void 0 ? _a$1 : (_b = params === null || params === void 0 ? void 0 : params.alphaFeatures) === null || _b === void 0 ? void 0 : _b.timelinePreview;
	return {
		enabled: checkEnableTimelinePreviewIsAllowed(host, timelinePreview),
		timelinePreview
	};
};

//#endregion
//#region node_modules/contentful/dist/esm/utils/validate-params.js
function checkLocaleParamIsAll(query) {
	if (query.locale === "*") throw new ValidationError("locale", `The use of locale='*' is no longer supported.To fetch an entry in all existing locales,
      use client.withAllLocales instead of the locale='*' parameter.`);
}
function checkLocaleParamExists(query) {
	if (query.locale) throw new ValidationError("locale", "The `locale` parameter is not allowed");
}
function validateLocaleParam(query, isWithAllLocalesClient) {
	if (isWithAllLocalesClient) checkLocaleParamExists(query);
	else checkLocaleParamIsAll(query);
}
function validateResolveLinksParam(query) {
	if ("resolveLinks" in query) throw new ValidationError("resolveLinks", `The use of the 'resolveLinks' parameter is no longer supported. By default, links are resolved.
      If you do not want to resolve links, use client.withoutLinkResolution.`);
}
function validateRemoveUnresolvedParam(query) {
	if ("removeUnresolved" in query) throw new ValidationError("removeUnresolved", `The use of the 'removeUnresolved' parameter is no longer supported. By default, unresolved links are kept as link objects.
      If you do not want to include unresolved links, use client.withoutUnresolvableLinks.`);
}
function checkIncludeContentSourceMapsParamIsAllowed(host, includeContentSourceMaps) {
	if (includeContentSourceMaps === void 0) return false;
	if (typeof includeContentSourceMaps !== "boolean") throw new ValidationError("includeContentSourceMaps", `The 'includeContentSourceMaps' parameter must be a boolean.`);
	const includeContentSourceMapsIsAllowed = typeof host === "string" && host.startsWith("preview");
	if (includeContentSourceMaps && !includeContentSourceMapsIsAllowed) throw new ValidationError("includeContentSourceMaps", `The 'includeContentSourceMaps' parameter can only be used with the CPA. Please set host to 'preview.contentful.com' or 'preview.eu.contentful.com' to include Content Source Maps.
      `);
	return includeContentSourceMaps;
}
function checkEnableTimelinePreviewIsAllowed(host, timelinePreview) {
	if (timelinePreview === void 0) return false;
	const isValidConfig = isValidTimelinePreviewConfig(timelinePreview);
	const isValidHost = typeof host === "string" && host.startsWith("preview");
	if (isValidConfig && !isValidHost) throw new ValidationError("timelinePreview", `The 'timelinePreview' parameter can only be used with the CPA. Please set host to 'preview.contentful.com' or 'preview.eu.contentful.com' to enable Timeline Preview.
      `);
	return true;
}

//#endregion
//#region node_modules/contentful/dist/esm/utils/validate-search-parameters.js
function validateSearchParameters(query) {
	for (const key in query) {
		const value = query[key];
		if (typeof value === "object" && value !== null && !Array.isArray(value)) throw new Error(`Objects are not supported as value for the "${key}" query parameter.`);
	}
}

//#endregion
//#region node_modules/tslib/tslib.es6.mjs
function __rest(s, e) {
	var t = {};
	for (var p$1 in s) if (Object.prototype.hasOwnProperty.call(s, p$1) && e.indexOf(p$1) < 0) t[p$1] = s[p$1];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p$1 = Object.getOwnPropertySymbols(s); i < p$1.length; i++) if (e.indexOf(p$1[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p$1[i])) t[p$1[i]] = s[p$1[i]];
	}
	return t;
}

//#endregion
//#region node_modules/contentful/dist/esm/utils/normalize-cursor-pagination-parameters.js
function normalizeCursorPaginationParameters(query) {
	const { cursor, pagePrev, pageNext, skip } = query, rest = __rest(query, [
		"cursor",
		"pagePrev",
		"pageNext",
		"skip"
	]);
	return Object.assign(Object.assign(Object.assign(Object.assign({}, rest), { cursor: true }), !!pagePrev && { pagePrev }), !!pageNext && { pageNext });
}

//#endregion
//#region node_modules/contentful/dist/esm/utils/normalize-cursor-pagination-response.js
function extractQueryParam(key, url) {
	const queryString = url === null || url === void 0 ? void 0 : url.split("?")[1];
	if (!queryString) return;
	return new URLSearchParams(queryString).get(key);
}
var Pages = {
	prev: "pagePrev",
	next: "pageNext"
};
function normalizeCursorPaginationResponse(response) {
	const pages = {};
	for (const [responseKey, queryKey] of Object.entries(Pages)) {
		const cursorToken = extractQueryParam(queryKey, response.pages[responseKey]);
		if (cursorToken) pages[responseKey] = cursorToken;
	}
	return Object.assign(Object.assign({}, response), { pages });
}

//#endregion
//#region node_modules/contentful/dist/esm/create-contentful-api.js
/**
* Contentful Delivery API Client. Contains methods which allow access to the
* different kinds of entities present in Contentful (Entries, Assets, etc).
*/
var ASSET_KEY_MAX_LIFETIME = 2880 * 60;
var NotFoundError = class extends Error {
	constructor(id, environment, space) {
		super("The resource could not be found.");
		this.sys = {
			type: "Error",
			id: "NotFound"
		};
		this.details = {
			type: "Entry",
			id,
			environment,
			space
		};
	}
};
function createContentfulApi({ http, getGlobalOptions }, options) {
	const notFoundError = (id = "unknown") => {
		return new NotFoundError(id, getGlobalOptions().environment, getGlobalOptions().space);
	};
	const getBaseUrl = (context) => {
		let baseUrl = context === "space" ? getGlobalOptions().spaceBaseUrl : getGlobalOptions().environmentBaseUrl;
		if (!baseUrl) throw new Error("Please define baseUrl for " + context);
		if (!baseUrl.endsWith("/")) baseUrl += "/";
		return baseUrl;
	};
	function maybeEnableSourceMaps(query = {}) {
		var _a$1, _b;
		const params = http.httpClientParams;
		const includeContentSourceMaps = (_a$1 = params === null || params === void 0 ? void 0 : params.includeContentSourceMaps) !== null && _a$1 !== void 0 ? _a$1 : (_b = params === null || params === void 0 ? void 0 : params.alphaFeatures) === null || _b === void 0 ? void 0 : _b.includeContentSourceMaps;
		if (checkIncludeContentSourceMapsParamIsAllowed(params === null || params === void 0 ? void 0 : params.host, includeContentSourceMaps)) {
			query.includeContentSourceMaps = true;
			if (query.select) {
				const selection = getQuerySelectionSet(query);
				selection.add("sys");
				query.select = Array.from(selection).join(",");
			}
		}
		return query;
	}
	function maybeEnableTimelinePreview(path) {
		const { enabled } = getTimelinePreviewParams(http.httpClientParams);
		return enabled ? `timeline/${path}` : path;
	}
	function maybeAddTimelinePreviewConfigToQuery(query) {
		const { enabled, timelinePreview } = getTimelinePreviewParams(http.httpClientParams);
		if (enabled) {
			if (timelinePreview === null || timelinePreview === void 0 ? void 0 : timelinePreview.release) query.release = timelinePreview.release;
			if (timelinePreview === null || timelinePreview === void 0 ? void 0 : timelinePreview.timestamp) query.timestamp = timelinePreview.timestamp;
		}
		return query;
	}
	function maybeEncodeCPAResponse(data, config) {
		var _a$1;
		if ((_a$1 = config === null || config === void 0 ? void 0 : config.params) === null || _a$1 === void 0 ? void 0 : _a$1.includeContentSourceMaps) return le(data);
		return data;
	}
	async function get({ context, path, config }) {
		const baseUrl = getBaseUrl(context);
		try {
			return maybeEncodeCPAResponse((await http.get(baseUrl + path, config)).data, config);
		} catch (error) {
			errorHandler(error);
		}
	}
	async function post({ context, path, data, config }) {
		const baseUrl = getBaseUrl(context);
		try {
			return (await http.post(baseUrl + path, data, config)).data;
		} catch (error) {
			errorHandler(error);
		}
	}
	async function getSpace() {
		return get({
			context: "space",
			path: ""
		});
	}
	async function getContentType(id) {
		return get({
			context: "environment",
			path: `content_types/${id}`
		});
	}
	async function getContentTypes(query = {}) {
		return get({
			context: "environment",
			path: "content_types",
			config: createRequestConfig({ query })
		});
	}
	async function getEntry(id, query = {}) {
		return makeGetEntry(id, query, options);
	}
	async function getEntries(query = {}) {
		return makeGetEntries(query, options);
	}
	async function getEntriesWithCursor(query = {}) {
		return normalizeCursorPaginationResponse(await makeGetEntries(normalizeCursorPaginationParameters(query), options));
	}
	async function makeGetEntry(id, query, options$1 = {
		withAllLocales: false,
		withoutLinkResolution: false,
		withoutUnresolvableLinks: false
	}) {
		const { withAllLocales } = options$1;
		validateLocaleParam(query, withAllLocales);
		validateResolveLinksParam(query);
		validateRemoveUnresolvedParam(query);
		validateSearchParameters(query);
		return internalGetEntry(id, withAllLocales ? Object.assign(Object.assign({}, query), { locale: "*" }) : query, options$1);
	}
	async function internalGetEntry(id, query, options$1) {
		if (!id) throw notFoundError(id);
		try {
			const response = await internalGetEntries(Object.assign({ "sys.id": id }, maybeEnableSourceMaps(query)), options$1);
			if (response.items.length > 0) return response.items[0];
			else throw notFoundError(id);
		} catch (error) {
			errorHandler(error);
		}
	}
	async function makeGetEntries(query, options$1 = {
		withAllLocales: false,
		withoutLinkResolution: false,
		withoutUnresolvableLinks: false
	}) {
		const { withAllLocales } = options$1;
		validateLocaleParam(query, withAllLocales);
		validateResolveLinksParam(query);
		validateRemoveUnresolvedParam(query);
		validateSearchParameters(query);
		return internalGetEntries(withAllLocales ? Object.assign(Object.assign({}, query), { locale: "*" }) : query, options$1);
	}
	function prepareQuery(query) {
		return maybeEnableSourceMaps(normalizeSearchParameters(normalizeSelect(maybeAddTimelinePreviewConfigToQuery(Object.assign({}, query)))));
	}
	async function internalGetEntries(query, options$1) {
		const { withoutLinkResolution, withoutUnresolvableLinks } = options$1;
		try {
			return resolveCircular(await get({
				context: "environment",
				path: maybeEnableTimelinePreview("entries"),
				config: createRequestConfig({ query: prepareQuery(query) })
			}), {
				resolveLinks: !withoutLinkResolution,
				removeUnresolved: withoutUnresolvableLinks !== null && withoutUnresolvableLinks !== void 0 ? withoutUnresolvableLinks : false
			});
		} catch (error) {
			errorHandler(error);
		}
	}
	async function getAsset(id, query = {}) {
		return makeGetAsset(id, query, options);
	}
	async function getAssets(query = {}) {
		return makeGetAssets(query, options);
	}
	async function getAssetsWithCursor(query = {}) {
		return normalizeCursorPaginationResponse(await makeGetAssets(normalizeCursorPaginationParameters(query), options));
	}
	async function makeGetAssets(query, options$1 = {
		withAllLocales: false,
		withoutLinkResolution: false,
		withoutUnresolvableLinks: false
	}) {
		const { withAllLocales } = options$1;
		validateLocaleParam(query, withAllLocales);
		validateSearchParameters(query);
		return internalGetAssets(withAllLocales ? Object.assign(Object.assign({}, query), { locale: "*" }) : query);
	}
	async function internalGetAsset(id, query) {
		try {
			return get({
				context: "environment",
				path: maybeEnableTimelinePreview(`assets/${id}`),
				config: createRequestConfig({ query: prepareQuery(query) })
			});
		} catch (error) {
			errorHandler(error);
		}
	}
	async function makeGetAsset(id, query, options$1 = {
		withAllLocales: false,
		withoutLinkResolution: false,
		withoutUnresolvableLinks: false
	}) {
		const { withAllLocales } = options$1;
		validateLocaleParam(query, withAllLocales);
		validateSearchParameters(query);
		return internalGetAsset(id, withAllLocales ? Object.assign(Object.assign({}, query), { locale: "*" }) : query);
	}
	async function internalGetAssets(query) {
		try {
			return get({
				context: "environment",
				path: maybeEnableTimelinePreview("assets"),
				config: createRequestConfig({ query: prepareQuery(query) })
			});
		} catch (error) {
			errorHandler(error);
		}
	}
	async function getTag$1(id) {
		return get({
			context: "environment",
			path: `tags/${id}`
		});
	}
	async function getTags(query = {}) {
		validateSearchParameters(query);
		return get({
			context: "environment",
			path: "tags",
			config: createRequestConfig({ query: normalizeSearchParameters(normalizeSelect(query)) })
		});
	}
	async function createAssetKey(expiresAt) {
		try {
			const now = Math.floor(Date.now() / 1e3);
			validateTimestamp("expiresAt", expiresAt, {
				maximum: now + ASSET_KEY_MAX_LIFETIME,
				now
			});
		} catch (error) {
			errorHandler(error);
		}
		return post({
			context: "environment",
			path: "asset_keys",
			data: { expiresAt }
		});
	}
	async function getLocales(query = {}) {
		validateSearchParameters(query);
		return get({
			context: "environment",
			path: "locales",
			config: createRequestConfig({ query: normalizeSelect(query) })
		});
	}
	async function sync(query, syncOptions = { paginate: true }) {
		return makePagedSync(query, syncOptions, options);
	}
	async function makePagedSync(query, syncOptions, options$1 = {
		withAllLocales: false,
		withoutLinkResolution: false,
		withoutUnresolvableLinks: false
	}) {
		validateResolveLinksParam(query);
		validateRemoveUnresolvedParam(query);
		const combinedOptions = Object.assign(Object.assign({}, syncOptions), options$1);
		switchToEnvironment(http);
		return pagedSync(http, query, combinedOptions);
	}
	function parseEntries(data) {
		return makeParseEntries(data, options);
	}
	function makeParseEntries(data, options$1 = {
		withAllLocales: false,
		withoutLinkResolution: false,
		withoutUnresolvableLinks: false
	}) {
		return internalParseEntries(data, options$1);
	}
	function internalParseEntries(data, options$1) {
		const { withoutLinkResolution, withoutUnresolvableLinks } = options$1;
		return resolveCircular(data, {
			resolveLinks: !withoutLinkResolution,
			removeUnresolved: withoutUnresolvableLinks !== null && withoutUnresolvableLinks !== void 0 ? withoutUnresolvableLinks : false
		});
	}
	function getConceptScheme(id, query = {}) {
		return internalGetConceptScheme(id, query);
	}
	async function internalGetConceptScheme(id, query = {}) {
		try {
			return get({
				context: "environment",
				path: `taxonomy/concept-schemes/${id}`,
				config: createRequestConfig({ query: normalizeSearchParameters(normalizeSelect(query)) })
			});
		} catch (error) {
			errorHandler(error);
		}
	}
	function getConceptSchemes(query = {}) {
		return internalGetConceptSchemes(query);
	}
	async function internalGetConceptSchemes(query = {}) {
		try {
			return get({
				context: "environment",
				path: "taxonomy/concept-schemes",
				config: createRequestConfig({ query: normalizeSearchParameters(normalizeSelect(query)) })
			});
		} catch (error) {
			errorHandler(error);
		}
	}
	function getConcept(id, query = {}) {
		return internalGetConcept(id, query);
	}
	async function internalGetConcept(id, query = {}) {
		try {
			return get({
				context: "environment",
				path: `taxonomy/concepts/${id}`,
				config: createRequestConfig({ query: normalizeSearchParameters(normalizeSelect(query)) })
			});
		} catch (error) {
			errorHandler(error);
		}
	}
	function getConcepts(query = {}) {
		return internalGetConcepts(query);
	}
	async function internalGetConcepts(query = {}) {
		try {
			return get({
				context: "environment",
				path: "taxonomy/concepts",
				config: createRequestConfig({ query: normalizeSearchParameters(normalizeSelect(query)) })
			});
		} catch (error) {
			errorHandler(error);
		}
	}
	function getConceptAncestors(id, query = {}) {
		return internalGetConceptAncestors(id, query);
	}
	async function internalGetConceptAncestors(id, query = {}) {
		try {
			return get({
				context: "environment",
				path: `taxonomy/concepts/${id}/ancestors`,
				config: createRequestConfig({ query: normalizeSearchParameters(normalizeSelect(query)) })
			});
		} catch (error) {
			errorHandler(error);
		}
	}
	function getConceptDescendants(id, query = {}) {
		return internalGetConceptDescendants(id, query);
	}
	async function internalGetConceptDescendants(id, query = {}) {
		try {
			return get({
				context: "environment",
				path: `taxonomy/concepts/${id}/descendants`,
				config: createRequestConfig({ query: normalizeSearchParameters(normalizeSelect(query)) })
			});
		} catch (error) {
			errorHandler(error);
		}
	}
	function switchToEnvironment(http$1) {
		http$1.defaults.baseURL = getGlobalOptions().environmentBaseUrl;
	}
	return {
		version: "0.0.0-determined-by-semantic-release",
		getSpace,
		getContentType,
		getContentTypes,
		getAsset,
		getAssets,
		getAssetsWithCursor,
		getTag: getTag$1,
		getTags,
		getLocales,
		parseEntries,
		sync,
		getEntry,
		getEntries,
		getEntriesWithCursor,
		getConceptScheme,
		getConceptSchemes,
		getConcept,
		getConcepts,
		getConceptAncestors,
		getConceptDescendants,
		createAssetKey
	};
}

//#endregion
//#region node_modules/contentful/dist/esm/make-client.js
function create({ http, getGlobalOptions }, options, makeInnerClient) {
	const client = createContentfulApi({
		http,
		getGlobalOptions
	}, options);
	const response = client ? client : {};
	Object.defineProperty(response, "withAllLocales", { get: () => makeInnerClient(Object.assign(Object.assign({}, options), { withAllLocales: true })) });
	Object.defineProperty(response, "withoutLinkResolution", { get: () => makeInnerClient(Object.assign(Object.assign({}, options), { withoutLinkResolution: true })) });
	Object.defineProperty(response, "withoutUnresolvableLinks", { get: () => makeInnerClient(Object.assign(Object.assign({}, options), { withoutUnresolvableLinks: true })) });
	return Object.create(response);
}
var makeClient = ({ http, getGlobalOptions }) => {
	function makeInnerClient(options) {
		return create({
			http,
			getGlobalOptions
		}, options, makeInnerClient);
	}
	const client = createContentfulApi({
		http,
		getGlobalOptions
	}, {
		withoutLinkResolution: false,
		withAllLocales: false,
		withoutUnresolvableLinks: false
	});
	return Object.assign(Object.assign({}, client), {
		get withAllLocales() {
			return makeInnerClient({
				withAllLocales: true,
				withoutLinkResolution: false,
				withoutUnresolvableLinks: false
			});
		},
		get withoutLinkResolution() {
			return makeInnerClient({
				withAllLocales: false,
				withoutLinkResolution: true,
				withoutUnresolvableLinks: false
			});
		},
		get withoutUnresolvableLinks() {
			return makeInnerClient({
				withAllLocales: false,
				withoutLinkResolution: false,
				withoutUnresolvableLinks: true
			});
		}
	});
};

//#endregion
//#region node_modules/contentful/dist/esm/contentful.js
/**
* Contentful Delivery API SDK. Allows you to create instances of a client
* with access to the Contentful Content Delivery API.
*/
/**
* Create a client instance
* @param params - Client initialization parameters
* @category Client
* @example
* ```typescript
* const contentful = require('contentful')
* const client = contentful.createClient({
*   accessToken: 'myAccessToken',
*   space: 'mySpaceId'
* })
* ```
*/
function createClient(params) {
	if (!params.accessToken) throw new TypeError("Expected parameter accessToken");
	if (!params.space) throw new TypeError("Expected parameter space");
	validateResolveLinksParam(params);
	validateRemoveUnresolvedParam(params);
	const config = Object.assign(Object.assign({}, {
		resolveLinks: true,
		removeUnresolved: false,
		defaultHostname: "cdn.contentful.com",
		environment: "master"
	}), params);
	const userAgentHeader = getUserAgentHeader(`contentful.js/0.0.0-determined-by-semantic-release`, config.application, config.integration);
	config.headers = Object.assign(Object.assign({}, config.headers), {
		"Content-Type": "application/vnd.contentful.delivery.v1+json",
		"X-Contentful-User-Agent": userAgentHeader
	});
	const http = createHttpClient(axios_default, config);
	if (!http.defaults.baseURL) throw new Error("Please define a baseURL");
	const getGlobalOptions = createGlobalOptions({
		space: config.space,
		environment: config.environment,
		spaceBaseUrl: http.defaults.baseURL,
		environmentBaseUrl: `${http.defaults.baseURL}environments/${config.environment}`
	});
	http.defaults.baseURL = getGlobalOptions({}).environmentBaseUrl;
	return makeClient({
		http,
		getGlobalOptions
	});
}

//#endregion
//#region node_modules/contentful/dist/esm/index.js
var import_stringify = require_stringify();

//#endregion
export { createClient, createGlobalOptions };
//# sourceMappingURL=contentful.js.map